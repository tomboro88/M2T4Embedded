[comment encoding = UTF-8 /]
[module request('http://www.eclipse.org/uml2/5.0.0/UML')]


[**
 * Gets the OrderedSet of parameters without the return parameter.
 * @param o The operation for which the list of parameters should be returned. 
 */]
[query public request_parameter_only(o : Operation) 
 : OrderedSet(Parameter) 
 = o.ownedParameter->select(direction <> ParameterDirectionKind::return)/]

[**
 * @brief Get the OrderedSet of the Operation return values.
 * @param o The operation for which the return values will be given.
 */]
[query public request_return_value(o : Operation) 
 : OrderedSet(Parameter) 
 = o.ownedParameter->select(direction = ParameterDirectionKind::return)/]

[**
 * Get a set of packages on which the given element depends. 
 */]
[query private request_dependency_packages(aNamedElement : NamedElement)
: Set(Package) = aNamedElement.clientDependency.supplier->collect(
       n:NamedElement | if n.oclIsKindOf(Package) then n.oclAsType(Package) 
       else n.eContainer(Package)endif)->asSet()/]

[**
 * @brief Get all subpackages of a package with a specified visibility. 
 */]
[query public request_visible_subpackages(aPackage : Package,
                            Visibilities : Set(VisibilityKind)) : Set(Package)
         =  aPackage.packagedElement->filter(Package
            )->select(p:Package | Visibilities->includes(p.visibility))/]

[**
 * @brief Get all children of a package with a specified visibility. 
 */]
[query private request_visible_children(aPackage : Package, 
                                      Visibilities : Set(VisibilityKind)) 
    : Set(PackageableElement) 
     = aPackage.packagedElement->select(p : PackageableElement | 
      Visibilities->includes(p.visibility))/]

[**
 * @brief Get a set of packages on which all non-Package children of the package
 * depend. 
 */]
[query public request_visible_dependencies(aPackage : Package,
                          Visibilities : Set(VisibilityKind)) : Set(Package) = 
   aPackage.request_dependency_packages()->union(
   request_visible_children(aPackage, Visibilities
   ).request_dependency_packages()
   )->union(request_visible_children(aPackage, Visibilities)
       ->reject(p:PackageableElement | p.oclIsKindOf(Package)
       ).eAllContents(NamedElement
       ).request_dependency_packages())->asSet()/]

[query public request_has_attributes(aClassifier:Classifier):Boolean = 
   not aClassifier.attribute->select(p : Property | not p.isStatic)->isEmpty()/]

[query public request_direct_children(aPackage : Package) : 
     Sequence(PackageableElement) 
     = aPackage.eContents(PackageableElement)->select(p : PackageableElement | 
       not p.oclIsKindOf(Package))/]

[query public request_non_packaged_children(aPackage : Package) : 
   Sequence(PackageableElement) = 
   let directChildren : Sequence(PackageableElement) 
                      = aPackage.request_direct_children() in
   directChildren->union(directChildren.eAllContents(PackageableElement))/]

[query public request_all_visibilities(traceabilityContext : OclAny) : 
      Set(VisibilityKind) = 
      Set{VisibilityKind::public, VisibilityKind::protected, 
      VisibilityKind::_package, VisibilityKind::private}/]
[**
 * Returns the last whitespace index in the string up to th given index.
 */]
[query public  request_last_whitespace_index(aString:String, upto:Integer) 
: Integer = let space_index : Integer = aString.lastIndex(' ', upto) in
  let tab_index : Integer = aString.lastIndex('\t', upto) in
  tab_index.max(space_index)/]

[query public request_needs_generalization_storage(aClassifier : Classifier) 
: Boolean = aClassifier.generalization->exists(g : Generalization 
   | g.general.request_needs_storage())/]

[query public request_needs_storage(aClassifier : Classifier) 
: Boolean = aClassifier.request_has_attributes() 
            or aClassifier.request_needs_generalization_storage()
            or aClassifier.request_needs_vtable()/]

[query private request_needs_generalization_vtable(aClassifier : Classifier) 
  : Boolean = aClassifier.generalization->exists(g : Generalization
    | g.general.request_needs_vtable())/]

[query public request_needs_vtable(aClassifier : Classifier) : Boolean 
 = aClassifier.request_has_virtual_operations()
   or aClassifier.request_needs_generalization_vtable()/]

[query public request_all_generals(aClassifier:Classifier) : Set(Classifier) = 
 aClassifier.general->addAll(aClassifier.general.request_all_generals())/]

[query public request_sort_classifiers(aSeq : Sequence(Classifier)) : 
  Sequence(Classifier)
  = if aSeq->size() <=1 then aSeq
    else 
      let aRest : Sequence(Classifier) = aSeq->drop(1) in
      let aFirst : Classifier = aSeq->first() in
      let aRest_dependencies:Sequence(Classifier) = aRest->select(
          c:Classifier | aFirst.request_classifier_depends(c)) in
      let aRest_non_dependencies:Sequence(Classifier) 
          = aRest->removeAll(aRest_dependencies) in
      aRest_dependencies->request_sort_classifiers()->append(aFirst)
      ->union(aRest_non_dependencies->request_sort_classifiers())
    endif/]

[query public request_classifier_depends(aClassifier:Classifier,
                                       bClassifier:Classifier):Boolean
 =aClassifier.attribute.type->includes(bClassifier.oclAsType(Type))
  or aClassifier.attribute.type->exists(t:Type|
        t.oclAsType(Classifier).request_classifier_depends(bClassifier))
        or aClassifier.generalization.general->includes(bClassifier)
        or aClassifier.generalization.general
           ->exists(c:Classifier|c.request_classifier_depends(bClassifier))/]

[query public request_has_virtual_operations(aClassifier : Classifier) : Boolean 
 = not aClassifier.request_virtual_operations()->isEmpty()/]

[query public request_virtual_operations(aClassifier : Classifier) : 
 OrderedSet(Operation) = 
          aClassifier.ownedMember->filter(Operation)
                 ->select(o : Operation | (not o.isStatic) 
                       and (o.isAbstract or aClassifier.oclIsKindOf(Interface)
                       or o.method._context.request_all_generals()
                        ->includes(aClassifier)))
                 ->sortedBy(o:Operation|o.name.toLower())/]

[query public request_method_from_context(aTree : Sequence(Classifier),
                                  anOperation : Operation) : Behavior =
  if aTree->size() > 0 then 
   let bhv : Behavior = anOperation.method->any(
   b : Behavior | b._context.oclAsType(Classifier) = aTree->first()) in 
   if bhv.oclIsUndefined() 
      and not anOperation.featuringClassifier->includes(aTree->first()) then 
      request_method_from_context(aTree->drop(1),anOperation)
   else bhv endif
  else null endif/]

[query public request_has_operation_spec(aBehavior : Behavior,
                                         vis : Set(VisibilityKind)) : Boolean =
    vis->includes(aBehavior.visibility) 
    and (not aBehavior.specification.oclIsUndefined())
    and aBehavior.specification.oclIsKindOf(Operation) 
 /]

[query public request_behaviors(aClassifier : Classifier) : Set(Behavior) = 
  aClassifier.ownedMember->filter(Behavior)/]