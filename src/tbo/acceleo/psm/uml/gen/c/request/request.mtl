[comment encoding = UTF-8 /]
[module request('http://www.eclipse.org/uml2/5.0.0/UML')]


[**
 * Filters the OrderedSet of parameters from the return parameter.
 * @param oP The list of parameters should be filtered. 
 */]
[query public request_parameter_only(osP : OrderedSet(Parameter)) 
 : OrderedSet(Parameter) 
 = osP->select(direction <> ParameterDirectionKind::return)/]

[**
 * @brief Get the OrderedSet of the Operation return values.
 * @param o The operation for which the return values will be given.
 */]
[query public request_return_value(osP : OrderedSet(Parameter)) 
 : OrderedSet(Parameter) 
 = osP->select(direction = ParameterDirectionKind::return)/]

[**
 * Get a set of packages on which the given element depends. 
 */]
[query private request_dependency_packages(aNamedElement : NamedElement)
: Set(Package) = aNamedElement.clientDependency.supplier->collect(
       n:NamedElement | if n.oclIsKindOf(Package) then n.oclAsType(Package) 
       else n.eContainer(Package)endif)->asSet()/]

[**
 * @brief Get all subpackages of a package with a specified visibility. 
 */]
[query public request_visible_subpackages(aPackage : Package,
                            Visibilities : Set(VisibilityKind)) : Set(Package)
         =  aPackage.packagedElement->filter(Package
            )->select(p:Package | Visibilities->includes(p.visibility))/]

[**
 * @brief Get all children of a package with a specified visibility. 
 */]
[query private request_visible_children(aPackage : Package, 
                                      Visibilities : Set(VisibilityKind)) 
    : Set(PackageableElement) 
     = aPackage.packagedElement->select(p : PackageableElement | 
      Visibilities->includes(p.visibility))/]

[**
 * @brief Get a set of packages on which all non-Package children of the package
 * depend. 
 */]
[query public request_visible_dependencies(aPackage : Package,
                          Visibilities : Set(VisibilityKind)) : Set(Package) = 
   aPackage.request_dependency_packages()->union(
   request_visible_children(aPackage, Visibilities
   ).request_dependency_packages()
   )->union(request_visible_children(aPackage, Visibilities)
       ->reject(p:PackageableElement | p.oclIsKindOf(Package)
       ).eAllContents(NamedElement
       ).request_dependency_packages())->asSet()/]

[query public request_has_attributes(aClassifier:Classifier):Boolean = 
   not aClassifier.attribute->select(p : Property | not p.isStatic)->isEmpty()/]

[query public request_owns_states(aClassifier:Classifier) : Boolean = 
  aClassifier.oclIsKindOf(StateMachine) and 
   not aClassifier.oclAsType(StateMachine).region.subvertex->selectByKind(State)
       ->isEmpty() /]

[query public request_has_states(aClassifier:Classifier):Boolean = 
   aClassifier.request_owns_states()
   or (aClassifier.oclIsKindOf(BehavioredClassifier) 
       and not aClassifier.oclAsType(BehavioredClassifier).ownedBehavior
      ->select(b:Behavior | b.request_has_states())->isEmpty()) /]

[query public request_direct_children(aPackage : Package) : 
     Sequence(PackageableElement) 
     = aPackage.eContents(PackageableElement)->select(p : PackageableElement | 
       not p.oclIsKindOf(Package))/]

[query public request_non_packaged_children(aPackage : Package) : 
   Sequence(PackageableElement) = 
   let directChildren : Sequence(PackageableElement) 
                      = aPackage.request_direct_children() in
   directChildren->union(directChildren.eAllContents(PackageableElement))/]

[query public request_all_visibilities(traceabilityContext : OclAny) : 
      Set(VisibilityKind) = 
      Set{VisibilityKind::public, VisibilityKind::protected, 
      VisibilityKind::_package, VisibilityKind::private}/]
[**
 * Returns the last whitespace index in the string up to th given index.
 */]
[query public  request_last_whitespace_index(aString:String, upto:Integer) 
: Integer = let space_index : Integer = aString.lastIndex(' ', upto) in
  let tab_index : Integer = aString.lastIndex('\t', upto) in
  tab_index.max(space_index)/]

[query public request_needs_generalization_storage(aClassifier : Classifier) 
: Boolean = aClassifier.generalization->exists(g : Generalization 
   | g.general.request_has_fields())/]

[query public request_provides_nontemplate_fields(aClassifier : Classifier) 
 : Boolean = 
 aClassifier.request_has_attributes() 
 or aClassifier.request_needs_generalization_storage()
 or aClassifier.request_has_states()
 
 or aClassifier.request_has_virtual_operations()/]

[query public request_provides_fields(aClassifier : Classifier) : Boolean = 
 aClassifier.request_provides_nontemplate_fields() 
 or aClassifier.request_needs_vtable()/] 

[query public request_has_fields(aClassifier : Classifier) : Boolean = 
 aClassifier.request_provides_fields() 
 or aClassifier.templateBinding->exists(tb : TemplateBinding | 
               tb.signature.template.oclAsType(Classifier)
               .request_has_fields())/] 

[query public request_needs_storage(aClassifier : Classifier) 
: Boolean = not aClassifier.isTemplate() 
            and aClassifier.request_has_fields()/]

[query private request_needs_generalization_vtable(aClassifier : Classifier) 
  : Boolean = aClassifier.generalization->exists(g : Generalization
    | g.general.request_needs_vtable())/]

[query public request_needs_vtable(aClassifier : Classifier) : Boolean 
 = aClassifier.request_has_virtual_operations()
   or aClassifier.request_needs_generalization_vtable()
   or aClassifier.templateBinding->exists(tb : TemplateBinding | 
               tb.signature.template.oclAsType(Classifier)
               .request_needs_vtable())/]

[query public request_all_generals(aClassifier:Classifier) : Set(Classifier) = 
 aClassifier.general->addAll(aClassifier.general.request_all_generals())/]

[query public request_sort_classifiers(anOSet : OrderedSet(Classifier)) : 
  OrderedSet(Classifier)
  = if anOSet->size() <=1 then anOSet
    else 
      let aRest : OrderedSet(Classifier) = anOSet->drop(1) in
      let aFirst : Classifier = anOSet->first() in
      let aRest_dependencies:OrderedSet(Classifier) = aRest->select(
          c:Classifier | aFirst.request_classifier_depends(c)) in
      let aRest_non_dependencies:OrderedSet(Classifier) 
          = aRest->removeAll(aRest_dependencies) in
      aRest_dependencies->request_sort_classifiers()->append(aFirst)
      ->addAll(aRest_non_dependencies->request_sort_classifiers())
    endif/]

[query public request_classifier_depends(aClassifier:Classifier,
                                       bClassifier:Classifier):Boolean
 =aClassifier.attribute.type->includes(bClassifier.oclAsType(Type))
  or aClassifier.attribute.type->exists(t:Type|
        t.oclAsType(Classifier).request_classifier_depends(bClassifier))
        or aClassifier.generalization.general->includes(bClassifier)
        or aClassifier.generalization.general
           ->exists(c:Classifier|c.request_classifier_depends(bClassifier))/]

[query public request_has_virtual_operations(aClassifier : Classifier) : Boolean 
 = not aClassifier.request_virtual_operations()->isEmpty()/]

[**
 * @brief Returns true if an operation can be overriden in child classes. 
 */]
[query public request_is_virtual_operation(o : Operation) : Boolean
 = (not o.isStatic) and (o.isAbstract or 
    let aClassifier : Classifier = 
    o.featuringClassifier->any(c : Classifier| not c.oclIsUndefined()) in 
    if aClassifier.oclIsUndefined() then false 
    else aClassifier.oclIsKindOf(Interface)
         or o.method._context.request_all_generals()->includes(aClassifier) 
    endif )/]

[query public request_is_constructor(anOperation : Operation) : Boolean =
 not anOperation.getAppliedStereotypes()
            ->select(s : Stereotype | s.name = 'Create')->isEmpty()/]

[query public request_virtual_operations(aClassifier : Classifier) : 
 OrderedSet(Operation) = 
          aClassifier.ownedMember->filter(Operation)
                 ->select(o : Operation | o.request_is_virtual_operation())
                 ->sortedBy(o:Operation|o.name.toLower())/]

[query public request_method_from_context(aTree : Sequence(Classifier),
                                  anOperation : Operation) : Behavior =
  if aTree->size() > 0 then 
   let bhv : Behavior = anOperation.method->any(
   b : Behavior | b._context.oclAsType(Classifier) = aTree->first()) in 
   if bhv.oclIsUndefined() 
      and not anOperation.featuringClassifier->includes(aTree->first()) then 
      request_method_from_context(aTree->drop(1),anOperation)
   else bhv endif
  else null endif/]

[query public request_has_operation_spec(aBehavior : Behavior,
                                         vis : Set(VisibilityKind)) : Boolean =
    vis->includes(aBehavior.visibility) 
    and (not aBehavior.specification.oclIsUndefined())
    and aBehavior.specification.oclIsKindOf(Operation) 
 /]

[query public request_has_virtual_operation_spec(b : Behavior,
                                         vis : Set(VisibilityKind)) : Boolean =
    b.request_has_operation_spec(vis) 
    and b.specification.oclAsType(Operation).request_is_virtual_operation()
 /]

[query public request_behaviors(aClassifier : BehavioredClassifier) : 
  Set(Behavior) = 
  aClassifier.ownedBehavior/]

[query public request_behavior_visibility(aBehavior : Behavior):VisibilityKind
 = if aBehavior.specification.oclIsUndefined() then VisibilityKind::private
   else if aBehavior.visibility.oclIsUndefined() then VisibilityKind::public
        else aBehavior.visibility endif endif/]

[query public request_standalone_behaviors(aClassifier:BehavioredClassifier, 
                                          vis : Set(VisibilityKind)) 
: Set(Behavior) = aClassifier.request_behaviors()
        ->select(b : Behavior | b.request_has_virtual_operation_spec(vis)
        or (b.specification.oclIsUndefined() 
             and vis->includes(b.request_behavior_visibility())))/]

[query public request_has_default_values(aClassifier : Classifier) : Boolean = 
  (not aClassifier.attribute->select(p : Property | 
                   not p.defaultValue.oclIsUndefined())->isEmpty())
  or (not (aClassifier.general.request_has_default_values()
      ->select(b:Boolean | b))->isEmpty()) /]

[**
 * @brief returns true if the classifier needs a constructor. 
 */]
[query public request_needs_constructor(aClassifier : Classifier) : Boolean = 
  aClassifier.request_needs_vtable() 
  or aClassifier.request_has_default_values()/]

[query public request_sorted_bindings(sB : Set(TemplateBinding)) 
: OrderedSet(TemplateBinding) = sB->sortedBy(aTB : TemplateBinding | 
     aTB.boundElement.oclAsType(Classifier).qualifiedName
     + aTB.signature.template.oclAsType(Classifier).qualifiedName
                    + aTB.signature.parameter
             ->collect(tP : TemplateParameter | aTB.parameterSubstitution
                 ->any(tps : TemplateParameterSubstitution | tps.formal = tP)
                 .actual).toString())/]

[query public request_needs_intermediate_binding(aClassifier : Classifier)
 : Boolean = aClassifier.templateBinding->size() > 1 or 
    (aClassifier.templateBinding->size() = 1
       and aClassifier.request_provides_nontemplate_fields())/]

[query public request_class_needs_event_defer(aClass : Class) : Boolean 
= not aClass.ownedBehavior.eAllContents(Transition)
->select(t : Transition | (not t.effect.oclIsUndefined()) and 
          t.effect.oclIsKindOf(OpaqueBehavior)).effect
  .oclAsType(OpaqueBehavior)->select(ob : OpaqueBehavior 
  | (ob._body->size() = 1) and (ob._body->first() = 'defer'))->isEmpty()/]

[query public request_event_needs_defer(aClass : Class, evt : Event) : Boolean 
= not aClass.ownedBehavior.eAllContents(Transition)
->select(t : Transition | (not t.effect.oclIsUndefined()) and 
    t.effect.oclIsKindOf(OpaqueBehavior) and (t.trigger.event->includes(evt))
          and (let ob : OpaqueBehavior = t.effect.oclAsType(OpaqueBehavior) in
               ob._body->size() = 1 and ob._body->first() = 'defer')
  )->isEmpty()/]

[query public request_is_direct_binding(aClassifier : Classifier)
 : Boolean = aClassifier.templateBinding->size() = 1 and 
    not aClassifier.request_provides_nontemplate_fields()/]

[query public request_regions_sorted(sr:Set(Region)) : OrderedSet(Region) = 
 sr->asOrderedSet()
 ->sortedBy(r:Region|r.containingStateMachine().eAllContents()->indexOf(r)) /]

[query public request_is_in_region(v:Vertex,r:Region):Boolean = 
 (v.container = r) /]

[query public request_all_regions(sm:StateMachine):OrderedSet(Region)
  = sm.eAllContents(Region)->select(r:Region|r.containingStateMachine() = sm)
      ->asOrderedSet()/]

[query public request_region_states(r:Region) : OrderedSet(State) = 
    r.request_region_vertices()->selectByKind(State)/]

[query public request_region_vertices(r:Region) : OrderedSet(Vertex) =
    request_elements_sorted(r.subvertex)/]

[**
 * @brief Returns all events that need to be handled in the region 
 */]
[query public request_region_events(aRegion:Region) : OrderedSet(Event) = 
    let states:Set(State) = aRegion.subvertex->selectByKind(State) in
    let state_events:OrderedSet(Event) = states
               ->collect(s:State|s.request_state_events())->flatten()
                                ->asOrderedSet() in
    request_elements_sorted(states->select(s:State|s.region->notEmpty())
                              .region->flatten()
                              .request_region_events()->flatten()->asSet()
                            ->addAll(state_events))/]

[**
 * @brief Returns an OrderedSet of events handled specifically by this state.
*/]
[query public request_state_events(aState:State) : OrderedSet(Event) =
    let events:Set(Event) = aState.outgoing.trigger->flatten()
        .event->select(e:Event|not e->oclIsUndefined())->asSet() in 
         request_elements_sorted(events)/]

[query public request_state_handles_event(aState:State, anEvent : Event) 
 : Boolean =
    aState.request_state_events()->includes(anEvent)/]

[query public request_vertex_region(v : Vertex) : Region = 
  v.container/]

[query public request_needs_event_loop(aClassifier : Classifier): Boolean  = 
    if aClassifier.oclIsKindOf(StateMachine) then
        aClassifier.oclAsType(Behavior)._context.oclIsUndefined()
    else
        aClassifier.oclIsKindOf(BehavioredClassifier) 
        and not aClassifier.oclAsType(BehavioredClassifier).ownedBehavior
            ->filter(StateMachine)->isEmpty()
    endif
/]

[query public request_class_events(aClass : Class): OrderedSet(Event)
 = aClass.eAllContents(Trigger)
                          ->select(t : Trigger | (not t.event.oclIsUndefined()))
                          .event->asOrderedSet()/]

[query public request_sm_events(sm : StateMachine): OrderedSet(Event)
 = request_elements_sorted(sm.eAllContents(Transition)
                      ->select(t : Transition | t.containingStateMachine() = sm)
                      ->collect(t:Transition|t.trigger)->flatten()
                      ->collect(tr:Trigger|tr.event)->asSet())
                      /]

[query public request_sm_context(sm: StateMachine) : 
  BehavioredClassifier = if sm._context.oclIsUndefined() then sm 
           else sm._context endif/]

[query public request_state_needs_region_exit(aState : State) : Boolean =  
 (aState.region->size() > 0) and
       aState.region->select(r : Region | r.request_region_needs_exit())
             ->notEmpty() /]

[query public request_state_needs_exit(aState : State): Boolean
 = (not aState.oclIsUndefined()) and ((not aState.exit.oclIsUndefined()) 
    or aState.request_state_needs_region_exit()) /]

[query public request_region_needs_exit(aRegion : Region): Boolean
 = aRegion.subvertex->selectByKind(State)
    ->select(st : State | st.request_state_needs_exit())->notEmpty()/]

[**
 * @brief Returns an OrderedSet of states that need to handle an event
*/]
[query public request_region_event_states(aRegion:Region, anEvent:Event) 
  : OrderedSet(State) = 
    aRegion.request_region_states()
                       ->select(s:State|s.request_state_handles_event(anEvent)
      or ((s.region->size() > 0 ) 
           and s.region->collect(r:Region|r.request_region_events())
                 ->flatten()->includes(anEvent)))/]

[query public request_event_subregions(regions:Set(Region), anEvent : Event)
  : OrderedSet(Region) = regions
           ->select(r:Region|r.request_region_events()->includes(anEvent))
           ->asOrderedSet()->sortedBy(r:Region|
                  r.containingStateMachine().eAllContents(Region)->indexOf(r))/]
[**
 * @brief Selects only transitions with 'else' guard.
*/]
[query public request_else_transitions(transitions : OrderedSet(Transition))
       : OrderedSet(Transition) = transitions
                 ->select(t:Transition | not t.guard.oclIsUndefined() 
                           and t.guard.oclIsKindOf(Expression) 
                           and t.guard.oclAsType(Expression).symbol = 'else')/]

[**
 * brief Selects transitions with specified guards, including 'else' guards.
*/]
[query public request_guard_transitions(transitions : OrderedSet(Transition))
       : OrderedSet(Transition) = transitions
                 ->select(t:Transition | not t.guard.oclIsUndefined())/]

[**
 * @brief Returns The topmost state that should be exited to execute the 
 * transition.
 */]
[query public request_transition_exit_state(aTransition:Transition) : State
 = 
      let sourceHierarchy : OrderedSet(State) =
        aTransition.source.request_parent_states() in
      let targetHierarchy : OrderedSet(State) = 
        aTransition.target.request_parent_states()in
      let exitHierarchy : OrderedSet(State) =
        sourceHierarchy->removeAll(targetHierarchy) in
      if exitHierarchy->isEmpty() then 
      if aTransition.source.oclIsKindOf(State) 
         then aTransition.source.oclAsType(State) else null endif
      else exitHierarchy->first() endif/]

[**
 * @brief Returns The states that should be entered to to complete the 
 * transition. The first state is the first to enter. Does not include the 
 * target state.
 */]
[query public request_transition_entry_states(aTransition:Transition) : 
OrderedSet(State)
 = 
      let sourceHierarchy : OrderedSet(State) =
        aTransition.source.request_parent_states() in
      let targetHierarchy : OrderedSet(State) = 
        aTransition.target.request_parent_states()in
      let entry_states : OrderedSet(State) = 
        targetHierarchy->removeAll(sourceHierarchy) in 
        if aTransition.source.oclIsKindOf(State) and
           aTransition.kind=TransitionKind::local
           and targetHierarchy->includes(aTransition.source.oclAsType(State))
           and targetHierarchy->first()=aTransition.source
        then entry_states->drop(1)
        else entry_states endif/]

[**
 * @brief Returns The states that should be entered to to complete the 
 * transition. the first state is the first to enter.
 */]
[query public request_transition_entry_vertices(aTransition:Transition) : 
OrderedSet(Vertex)
 = request_transition_entry_states(aTransition)->append(aTransition.target)
   /]

[**
 * @brief Returns The  additional regions that should be entered to 
 * complete the transition with the given entry vertex sequence. The first 
 * region is the first to enter.
 */]
[query public request_regions_init(anOS:OrderedSet(Vertex)) : 
OrderedSet(Region)
 = anOS->selectByKind(State)
       ->select(aState:State | aState.region->notEmpty())
       ->collect(aState : State | aState.region->request_regions_sorted()
                         ->select(r:Region|anOS->excludesAll(r.subvertex)))
       ->asOrderedSet()
   /]

[**
 * @brief Returns a list of parent state with the top most state in the 
 * hierarchy as the first.
 * @param aVertex The vertex for which parent hierarchy should be returned 
 */]
[query public request_parent_states(aVertex:Vertex):OrderedSet(State) = 
 if aVertex.container.state.oclIsUndefined() then
    OrderedSet{}
 else
    aVertex.container.state.request_parent_states()
                            ->append(aVertex.container.state)
 endif/]

[**
 * @brief Returns a list of parent regions with the top most region in the 
 * hierarchy as the first.
 * @param aRegion The region for which parent hierarchy should be returned 
 */]
[query public request_parent_regions(aRegion:Region):OrderedSet(Region) = 
 if aRegion.state.oclIsUndefined() then
    OrderedSet{}
 else
    aRegion.state.container.request_parent_regions()
                            ->append(aRegion.state.container)
 endif/]

[**
 * @brief Get a list of states that will be exited when the transition occurs.
 * Does not include substates of a compound source state. 
 * The topmost state is at index 0, child states are at lower indexes.
 */]
[query public request_transition_exit_states(aTransition : Transition):
OrderedSet(State) = 
 let exitState : State = aTransition.request_transition_exit_state() in
 let parentStates : OrderedSet(State) = if exitState.oclIsUndefined() 
       then OrderedSet{} else if aTransition.source.oclIsKindOf(State) then
           aTransition.source.request_parent_states()
                          ->append(aTransition.source.oclAsType(State)) 
       else aTransition.source.request_parent_states() endif endif in
 if parentStates->isEmpty() 
          then OrderedSet{} else parentStates
                               ->drop(parentStates->indexOf(exitState)) endif /]

[query public request_state_machine_states(sm:StateMachine):OrderedSet(State) = 
 sm.eAllContents(State)->select(s:State|s.containingStateMachine() = sm)
    ->asOrderedSet()/]

[query public request_state_machine_transitions(sm:StateMachine):
  OrderedSet(Transition) = 
 sm.eAllContents(Transition)
    ->select(t:Transition|t.containingStateMachine() = sm)
    ->asOrderedSet()/]

[query public request_transition_effect_region(aTransition:Transition):
  Region = let exit_state : State = aTransition.request_transition_exit_state()
  in if not exit_state.oclIsUndefined() then exit_state.request_vertex_region()
  else aTransition.source.request_vertex_region() endif/]

[query public request_region_effect_sm_transitions(aRegion:Region):
  OrderedSet(Transition) = aRegion.containingStateMachine()
      .request_state_machine_transitions()
      ->select(t:Transition|t.request_transition_effect_region()=aRegion)
      ->select(t:Transition|t.effect.request_behavior_needs_async_call())/]

[query public request_transitions_by_event(transitions:OrderedSet(Transition),
              anEvent:Event):
  OrderedSet(Transition) = 
  transitions->select(t:Transition|t.trigger->notEmpty() 
               and t.trigger->collect(tr:Trigger|tr.event)->includes(anEvent))/]

[query public request_is_top_level_region(aRegion : Region)
 : Boolean =
 let sm : StateMachine = aRegion.containingStateMachine() in  
  (sm.region->size() = 1) and (sm.region->includes(aRegion))/]

[query public request_outgoing_transitions(aVertex:Vertex, anEvent:Event):
 OrderedSet(Transition) = 
 let aStateMachine : StateMachine = aVertex.containingStateMachine() in
 aStateMachine.eAllContents(Transition)
 ->select(t:Transition|t.trigger.event->includes(anEvent))
 ->select(t:Transition|aVertex.outgoing->includes(t))->asOrderedSet()/]

[query public request_elements_sorted(aSet:Set(Element))
  :OrderedSet(Element) = aSet->sortedBy(e:Element|
          e.eContainer(Model).eAllContents()->indexOf(e))/]

[query public request_has_standalone_behaviors(aClassifier:Classifier, 
                                          vis : Set(VisibilityKind)):Boolean =
aClassifier.oclIsKindOf(BehavioredClassifier)
           and aClassifier.oclAsType(BehavioredClassifier)
               .request_standalone_behaviors(vis)->notEmpty()/]

[query public request_transition_needs_exit(aTransition:Transition):Boolean = 
let exitState : State = request_transition_exit_state(aTransition) in
    aTransition.kind = TransitionKind::external
      and (not exitState.oclIsUndefined())
      and  exitState.request_state_needs_exit()/]

[query public request_region_initial_pseudostates(r:Region) 
 : Set(Pseudostate) = 
 r.subvertex->selectByKind(Pseudostate)
   ->select(p:Pseudostate|p.kind=PseudostateKind::initial)/]

[query public request_region_has_initial_pseudostate(r:Region) : Boolean = 
 r.request_region_initial_pseudostates()->notEmpty()/]

[query public request_region_has_one_initial_pseudostate(r:Region) : Boolean = 
 r.request_region_initial_pseudostates()->size() = 1/]

[query public request_region_initial_pseudostate(r:Region) 
 : Pseudostate = 
   if r.request_region_has_one_initial_pseudostate() then
      r.request_region_initial_pseudostates()
          ->any(p:Pseudostate | not p.oclIsUndefined())
   else null endif/]

[query public request_behavior_needs_async_call(aBehavior:Behavior):Boolean = 
 (not aBehavior.oclIsUndefined()) and aBehavior.oclIsKindOf(StateMachine)/]

[**
 * Returns an OrderedSet of Vertices whose entry calls can be executed 
 * synchronously at the time they are called, with the exception of the last
 * Vertex, which can be called asynchronously in order to start the asynchronous
 * chain of calls.
*/]
[query public request_synchronous_entry_calls(anOSet:OrderedSet(Vertex))
 : OrderedSet(Vertex) = 
   let lastVertex : Vertex = 
    anOSet->select(v:Vertex | v.request_vertex_needs_async_entry())->first() in
   let lastIndex : Integer = if lastVertex.oclIsUndefined() then anOSet->size()
                             else anOSet->indexOf(lastVertex) endif in
   if anOSet->notEmpty() then anOSet->subOrderedSet(1, lastIndex)
   else anOSet endif/]

[query public request_vertex_needs_async_entry(v:Vertex):Boolean = 
  (v.oclIsKindOf(State) and 
    v.oclAsType(State).entry.request_behavior_needs_async_call())
  or (v.oclIsKindOf(Pseudostate) and 
       let p:Pseudostate = v.oclAsType(Pseudostate) in (
           (p.kind=PseudostateKind::initial and p.outgoing
             ->select(t:Transition|t.request_transition_needs_async_call())
             ->notEmpty())
       ))/]

[query public request_region_needs_async_entry(r:Region):Boolean =
   let p : Pseudostate = 
           r.request_region_initial_pseudostate() in
  (not p.oclIsUndefined()) and
  p.outgoing->select(t:Transition|t.request_transition_needs_async_call())
             ->notEmpty()/]

[query public request_transition_needs_async_call(aTransition:Transition)
 :Boolean = 
 aTransition.effect.request_behavior_needs_async_call()
 or (let target_vertices : OrderedSet(Vertex) = 
        aTransition.request_transition_target_vertices() in
    target_vertices
    ->select(v:Vertex|v.request_vertex_needs_async_entry())->notEmpty()
    or target_vertices->request_regions_init()
       ->select(r:Region|r.request_region_needs_async_entry())->notEmpty())/]

[**
 * @brief Returns a list of vertices that should be entered to make
 * the run to completion step finished. This list does not include 
 * the remaining regions that need to be initialized.
*/]
[query public request_transition_target_vertices(aTransition:Transition)
 : OrderedSet(Vertex) = request_transition_entry_states(aTransition)
                        ->append(aTransition.target)/]

[**
 * @brief Returns the list of the first synchronous entry call vertices
 * that should be called at the time the transition is fired. The rest vertices
 * will be called later after the async calls are completed.
*/]
[query public request_transition_target_sync_vertices(aTransition:Transition)
 : OrderedSet(Vertex) = 
 request_transition_target_vertices(aTransition)
                        ->request_synchronous_entry_calls()/]

[**
 * @brief Returns the list of the first synchronous entry call regions
 * that should be called at the time the transition is fired. The rest
 * of regions will be called later as the chain of asynchronous calls
 * executes.
*/]
[query public request_transition_target_sync_regions_init
                                                        (aTransition:Transition)
 : OrderedSet(Region) = 
 let sync_entry_calls : OrderedSet(Vertex) = 
     request_transition_target_sync_vertices(aTransition) in
 let last_vertex : Vertex = sync_entry_calls->last() in
 let only_sync_calls : OrderedSet(Vertex) = 
     if last_vertex.oclIsUndefined() 
        or not last_vertex.request_vertex_needs_async_entry() then
        sync_entry_calls else sync_entry_calls->dropRight(1) endif in
 only_sync_calls->request_regions_init() /]

[query public request_transition_dispatch_result(aTransition : Transition)
 : String = if aTransition.request_transition_needs_async_call() 
          then request_transition_transit_state() else 
          if aTransition.kind = TransitionKind::internal then 
                 request_transition_same_state()
          else request_transition_changed_state() endif endif/]

[query public request_transition_transit_state(traceabilityContext : OclAny)
 : String = 'TRANSITION'/]

[query public request_transition_ignored_state(traceabilityContext : OclAny)
 : String = 'IGNORED'/]

[query public request_transition_deferred_state(traceabilityContext : OclAny)
 : String = 'DEFERRED'/]

[query public request_transition_changed_state(traceabilityContext : OclAny)
 : String = 'CHANGEDSTATE'/]

[query public request_transition_same_state(traceabilityContext : OclAny)
 : String = 'SAMESTATE'/]

[query public request_sort_regions(anOSet : OrderedSet(Region)) : 
  OrderedSet(Region)
  = if anOSet->size() <=1 then anOSet
    else 
      let aRest : OrderedSet(Region) = anOSet->drop(1) in
      let aFirst : Region = anOSet->first() in
      let aRest_children:OrderedSet(Region) = aRest->select(
          r:Region | r.request_parent_regions()->includes(aFirst)) in
      let aRest_non_children:OrderedSet(Region) 
          = aRest->removeAll(aRest_children) in
      aRest_children->request_sort_regions()->append(aFirst)
      ->addAll(aRest_non_children->request_sort_regions())
    endif/]

