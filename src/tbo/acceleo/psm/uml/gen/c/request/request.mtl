[comment encoding = UTF-8 /]
[module request('http://www.eclipse.org/uml2/5.0.0/UML')]


[**
 * Filters the OrderedSet of parameters from the return parameter.
 * @param oP The list of parameters should be filtered. 
 */]
[query public request_parameter_only(osP : OrderedSet(Parameter)) 
 : OrderedSet(Parameter) 
 = osP->select(direction <> ParameterDirectionKind::return)/]

[**
 * @brief Get the OrderedSet of the Operation return values.
 * @param o The operation for which the return values will be given.
 */]
[query public request_return_value(osP : OrderedSet(Parameter)) 
 : OrderedSet(Parameter) 
 = osP->select(direction = ParameterDirectionKind::return)/]

[**
 * Get a set of packages on which the given element depends. 
 */]
[query private request_dependency_packages(aNamedElement : NamedElement)
: Set(Package) = aNamedElement.clientDependency.supplier->collect(
       n:NamedElement | if n.oclIsKindOf(Package) then n.oclAsType(Package) 
       else n.eContainer(Package)endif)->asSet()/]

[**
 * @brief Get all subpackages of a package with a specified visibility. 
 */]
[query public request_visible_subpackages(aPackage : Package,
                            Visibilities : Set(VisibilityKind)) : Set(Package)
         =  aPackage.packagedElement->filter(Package
            )->select(p:Package | Visibilities->includes(p.visibility))/]

[**
 * @brief Get all children of a package with a specified visibility. 
 */]
[query private request_visible_children(aPackage : Package, 
                                      Visibilities : Set(VisibilityKind)) 
    : Set(PackageableElement) 
     = aPackage.packagedElement->select(p : PackageableElement | 
      Visibilities->includes(p.visibility))/]

[**
 * @brief Get a set of packages on which all non-Package children of the package
 * depend. 
 */]
[query public request_visible_dependencies(aPackage : Package,
                          Visibilities : Set(VisibilityKind)) : Set(Package) = 
   aPackage.request_dependency_packages()->union(
   request_visible_children(aPackage, Visibilities
   ).request_dependency_packages()
   )->union(request_visible_children(aPackage, Visibilities)
       ->reject(p:PackageableElement | p.oclIsKindOf(Package)
       ).eAllContents(NamedElement
       ).request_dependency_packages())->asSet()/]

[query public request_has_attributes(aClassifier:Classifier):Boolean = 
   not aClassifier.attribute->select(p : Property | not p.isStatic)->isEmpty()/]

[query public request_owns_states(aClassifier:Classifier) : Boolean = 
  aClassifier.oclIsKindOf(StateMachine) and 
   not aClassifier.oclAsType(StateMachine).region.subvertex->selectByKind(State)
       ->isEmpty() /]

[query public request_has_states(aClassifier:Classifier):Boolean = 
   aClassifier.request_owns_states()
   or (aClassifier.oclIsKindOf(BehavioredClassifier) 
       and not aClassifier.oclAsType(BehavioredClassifier).ownedBehavior
      ->select(b:Behavior | b.request_has_states())->isEmpty()) /]

[query public request_direct_children(aPackage : Package) : 
     Sequence(PackageableElement) 
     = aPackage.eContents(PackageableElement)->select(p : PackageableElement | 
       not p.oclIsKindOf(Package))/]

[query public request_non_packaged_children(aPackage : Package) : 
   Sequence(PackageableElement) = 
   let directChildren : Sequence(PackageableElement) 
                      = aPackage.request_direct_children() in
   directChildren->union(directChildren.eAllContents(PackageableElement))/]

[query public request_all_visibilities(traceabilityContext : OclAny) : 
      Set(VisibilityKind) = 
      Set{VisibilityKind::public, VisibilityKind::protected, 
      VisibilityKind::_package, VisibilityKind::private}/]
[**
 * Returns the last whitespace index in the string up to th given index.
 */]
[query public  request_last_whitespace_index(aString:String, upto:Integer) 
: Integer = let space_index : Integer = aString.lastIndex(' ', upto) in
  let tab_index : Integer = aString.lastIndex('\t', upto) in
  tab_index.max(space_index)/]

[query public request_needs_generalization_storage(aClassifier : Classifier) 
: Boolean = aClassifier.generalization->exists(g : Generalization 
   | g.general.request_has_fields())/]

[query public request_provides_nontemplate_fields(aClassifier : Classifier) 
 : Boolean = 
 aClassifier.request_has_attributes() 
 or aClassifier.request_needs_generalization_storage()
 or aClassifier.request_has_states()
 
 or aClassifier.request_has_virtual_operations()/]

[query public request_provides_fields(aClassifier : Classifier) : Boolean = 
 aClassifier.request_provides_nontemplate_fields() 
 or aClassifier.request_needs_vtable()/] 

[query public request_has_fields(aClassifier : Classifier) : Boolean = 
 aClassifier.request_provides_fields() 
 or aClassifier.templateBinding->exists(tb : TemplateBinding | 
               tb.signature.template.oclAsType(Classifier)
               .request_has_fields())/] 

[query public request_needs_storage(aClassifier : Classifier) 
: Boolean = not aClassifier.isTemplate() 
            and aClassifier.request_has_fields()/]

[query private request_needs_generalization_vtable(aClassifier : Classifier) 
  : Boolean = aClassifier.generalization->exists(g : Generalization
    | g.general.request_needs_vtable())/]

[query public request_needs_vtable(aClassifier : Classifier) : Boolean 
 = aClassifier.request_has_virtual_operations()
   or aClassifier.request_needs_generalization_vtable()
   or aClassifier.templateBinding->exists(tb : TemplateBinding | 
               tb.signature.template.oclAsType(Classifier)
               .request_needs_vtable())/]

[query public request_all_generals(aClassifier:Classifier) : Set(Classifier) = 
 aClassifier.general->addAll(aClassifier.general.request_all_generals())/]

[query public request_sort_classifiers(anOSet : OrderedSet(Classifier)) : 
  OrderedSet(Classifier)
  = if anOSet->size() <=1 then anOSet
    else 
      let aRest : OrderedSet(Classifier) = anOSet->drop(1) in
      let aFirst : Classifier = anOSet->first() in
      let aRest_dependencies:OrderedSet(Classifier) = aRest->select(
          c:Classifier | aFirst.request_classifier_depends(c)) in
      let aRest_non_dependencies:OrderedSet(Classifier) 
          = aRest->removeAll(aRest_dependencies) in
      aRest_dependencies->request_sort_classifiers()->append(aFirst)
      ->addAll(aRest_non_dependencies->request_sort_classifiers())
    endif/]

[query public request_classifier_depends(aClassifier:Classifier,
                                       bClassifier:Classifier):Boolean
 =aClassifier.attribute.type->includes(bClassifier.oclAsType(Type))
  or aClassifier.attribute.type->exists(t:Type|
        t.oclAsType(Classifier).request_classifier_depends(bClassifier))
        or aClassifier.generalization.general->includes(bClassifier)
        or aClassifier.generalization.general
           ->exists(c:Classifier|c.request_classifier_depends(bClassifier))/]

[query public request_has_virtual_operations(aClassifier : Classifier) : Boolean 
 = not aClassifier.request_virtual_operations()->isEmpty()/]

[**
 * @brief Returns true if an operation can be overriden in child classes. 
 */]
[query public request_is_virtual_operation(o : Operation) : Boolean
 = (not o.isStatic) and (o.isAbstract or 
    let aClassifier : Classifier = 
    o.featuringClassifier->any(c : Classifier| not c.oclIsUndefined()) in 
    if aClassifier.oclIsUndefined() then false 
    else aClassifier.oclIsKindOf(Interface)
         or o.method._context.request_all_generals()->includes(aClassifier) 
    endif )/]

[query public request_is_constructor(anOperation : Operation) : Boolean =
 not anOperation.getAppliedStereotypes()
            ->select(s : Stereotype | s.name = 'Create')->isEmpty()/]

[query public request_virtual_operations(aClassifier : Classifier) : 
 OrderedSet(Operation) = 
          aClassifier.ownedMember->filter(Operation)
                 ->select(o : Operation | o.request_is_virtual_operation())
                 ->sortedBy(o:Operation|o.name.toLower())/]

[query public request_method_from_context(aTree : Sequence(Classifier),
                                  anOperation : Operation) : Behavior =
  if aTree->size() > 0 then 
   let bhv : Behavior = anOperation.method->any(
   b : Behavior | b._context.oclAsType(Classifier) = aTree->first()) in 
   if bhv.oclIsUndefined() 
      and not anOperation.featuringClassifier->includes(aTree->first()) then 
      request_method_from_context(aTree->drop(1),anOperation)
   else bhv endif
  else null endif/]

[query public request_has_operation_spec(aBehavior : Behavior,
                                         vis : Set(VisibilityKind)) : Boolean =
    vis->includes(aBehavior.visibility) 
    and (not aBehavior.specification.oclIsUndefined())
    and aBehavior.specification.oclIsKindOf(Operation) 
 /]

[query public request_has_virtual_operation_spec(b : Behavior,
                                         vis : Set(VisibilityKind)) : Boolean =
    b.request_has_operation_spec(vis) 
    and b.specification.oclAsType(Operation).request_is_virtual_operation()
 /]

[query public request_behaviors(aClassifier : Classifier) : Set(Behavior) = 
  aClassifier.ownedMember->filter(Behavior)/]

[query public request_standalone_behaviors(aClassifier:Classifier, 
                                          vis : Set(VisibilityKind)) 
: Set(Behavior) = aClassifier.request_behaviors()
        ->select(b : Behavior | b.request_has_virtual_operation_spec(vis)
        or (b.specification.oclIsUndefined() 
             and vis->includes(VisibilityKind::private)))/]

[query public request_have_virtual_behaviors(anOSet : OrderedSet(Classifier),
                                               vis : Set(VisibilityKind)) 
 : Boolean = not anOSet->select(c : Classifier | 
                          not c.request_standalone_behaviors(vis)->isEmpty())
             ->isEmpty()/]

[query public request_has_default_values(aClassifier : Classifier) : Boolean = 
  (not aClassifier.attribute->select(p : Property | 
                   not p.defaultValue.oclIsUndefined())->isEmpty())
  or (not (aClassifier.general.request_has_default_values()
      ->select(b:Boolean | b))->isEmpty()) /]

[**
 * @brief returns true if the classifier needs a constructor. 
 */]
[query public request_needs_constructor(aClassifier : Classifier) : Boolean = 
  aClassifier.request_needs_vtable() 
  or aClassifier.request_has_default_values()/]

[query public request_sorted_bindings(sB : Set(TemplateBinding)) 
: OrderedSet(TemplateBinding) = sB->sortedBy(aTB : TemplateBinding | 
     aTB.boundElement.oclAsType(Classifier).qualifiedName
     + aTB.signature.template.oclAsType(Classifier).qualifiedName
                    + aTB.signature.parameter
             ->collect(tP : TemplateParameter | aTB.parameterSubstitution
                 ->any(tps : TemplateParameterSubstitution | tps.formal = tP)
                 .actual).toString())/]

[query public request_needs_intermediate_binding(aClassifier : Classifier)
 : Boolean = aClassifier.templateBinding->size() > 1 or 
    (aClassifier.templateBinding->size() = 1
       and aClassifier.request_provides_nontemplate_fields())/]

[query public request_class_needs_event_defer(aClass : Class) : Boolean 
= not aClass.ownedBehavior.eAllContents(Transition)
->select(t : Transition | (not t.effect.oclIsUndefined()) and 
          t.effect.oclIsKindOf(OpaqueBehavior)).effect
  .oclAsType(OpaqueBehavior)->select(ob : OpaqueBehavior 
  | (ob._body->size() = 1) and (ob._body->first() = 'defer'))->isEmpty()/]

[query public request_event_needs_defer(aClass : Class, evt : Event) : Boolean 
= not aClass.ownedBehavior.eAllContents(Transition)
->select(t : Transition | (not t.effect.oclIsUndefined()) and 
    t.effect.oclIsKindOf(OpaqueBehavior) and (t.trigger.event->includes(evt))
          and (let ob : OpaqueBehavior = t.effect.oclAsType(OpaqueBehavior) in
               ob._body->size() = 1 and ob._body->first() = 'defer')
  )->isEmpty()/]

[query public request_is_direct_binding(aClassifier : Classifier)
 : Boolean = aClassifier.templateBinding->size() = 1 and 
    not aClassifier.request_provides_nontemplate_fields()/]

[query public request_regions_sorted(sr:Set(Region)) : OrderedSet(Region) = 
 sr->asOrderedSet()
 ->sortedBy(r:Region|r.containingStateMachine().eAllContents()->indexOf(r)) /]

[query public request_is_in_region(v:Vertex,r:Region):Boolean = 
 if (v.containingStateMachine() <> r.containingStateMachine()) then false
 else
 if (v.container = r) then true
 else
 if (v.container.state->isEmpty() or v.container.state.isOrthogonal) then false
 else v.container.state.request_is_in_region(r)
 endif endif endif/]

[query public request_all_orthogonal_regions(sm:StateMachine):OrderedSet(Region)
  = sm.region->addAll(
      sm.eAllContents(Region)->select(r:Region|r.containingStateMachine() = sm)
      ->select(r:Region|not r.state->isEmpty())
      ->select(r:Region|r.state.region->size()>1))->request_regions_sorted()/]

[query public request_region_states(r:Region) : OrderedSet(State) = 
    r.request_region_vertices()->selectByKind(State)/]

[query public request_region_vertices(r:Region) : OrderedSet(Vertex) = 
    r.containingStateMachine().eAllContents(Vertex)
      ->select(v:Vertex | 
                     v.containingStateMachine() = r.containingStateMachine())
      ->select(v:Vertex | r.containingStateMachine()
                         .request_all_orthogonal_regions()->excluding(r)
               ->forAll(R:Region|not v.request_is_in_region(R)))
      ->asOrderedSet()/]

[query public request_region_events(aRegion:Region) : OrderedSet(Event) = 
    let states:Set(State) = aRegion.subvertex->selectByKind(State) in
    let events:OrderedSet(Event) = states.outgoing->flatten().trigger->flatten()
                                .event->select(e:Event|not e->oclIsUndefined())
                                ->asOrderedSet() in
    states->select(s:State|not s.region->isEmpty()).region->flatten()
          .request_region_events()->flatten()->asOrderedSet()->addAll(events)/]

[query public request_state_events(aState:State) : OrderedSet(Event) =
    let events:OrderedSet(Event) = aState.outgoing.trigger->flatten()
                                .event->select(e:Event|not e->oclIsUndefined())
                                ->asOrderedSet() in events/]

[query public request_state_handles_event(aState:State, anEvent : Event) 
 : Boolean =
    aState.request_state_events()->includes(anEvent)/]

[query public request_parent_state_handles_event(aState:State, anEvent : Event) 
 : Boolean =
    (not aState.container.state.oclIsUndefined())
     and (not aState.container.state.isOrthogonal)
     and (aState.container.state.request_state_handles_event(anEvent)
      or aState.container.state.request_parent_state_handles_event(anEvent))/]

[query public request_parent_state_event_handler(aState:State, anEvent : Event) 
 : State =
    if (not aState.container.state.oclIsUndefined())
     and (not aState.container.state.isOrthogonal) then
        if aState.container.state.request_state_handles_event(anEvent) then
            aState.container.state
        else
            if aState.container.state
                     .request_parent_state_handles_event(anEvent) then
                aState.container.state
                                  .request_parent_state_event_handler(anEvent)
            else
                null
            endif
        endif
    else
     null
    endif/]

[query public request_region_initial_state(aRegion : Region) : Pseudostate = 
 let initialVertices : Set(Pseudostate) = 
     aRegion.subvertex->selectByKind(Pseudostate)
            ->select(pS:Pseudostate | pS.kind = PseudostateKind::initial) in 
     if(initialVertices->size() = 1) then initialVertices->any(true) 
     else null endif/]

[query public request_vertex_region(v : Vertex) : Region = 
  v.containingStateMachine().request_all_orthogonal_regions()
  ->select(r : Region | r.request_region_vertices()->includes(v))->any(true)/]

[query public request_needs_event_loop(aClassifier : Classifier): Boolean  = 
    if aClassifier.oclIsKindOf(StateMachine) then
        aClassifier.oclAsType(Behavior)._context.oclIsUndefined()
    else
        aClassifier.oclIsKindOf(BehavioredClassifier) 
        and not aClassifier.oclAsType(BehavioredClassifier).ownedBehavior
            ->filter(StateMachine)->isEmpty()
    endif
/]

[query public request_class_events(aClass : Class): OrderedSet(Event)
 = aClass.eAllContents(Trigger)
                          ->select(t : Trigger | not t.event.oclIsUndefined())
                          .event->asOrderedSet()/]

[query public request_sm_context(sm: StateMachine) : 
  BehavioredClassifier = if sm._context.oclIsUndefined() then sm 
           else sm._context endif/]

[query public request_parent_state_needs_exit(aState : State): Boolean
 = ((not aState.container.oclIsUndefined())
       and (not aState.container.state.oclIsUndefined()) 
       and (not aState.container.state.isOrthogonal)
       and aState.container.state.request_state_needs_exit()
      )/]

[query public request_state_needs_region_exit(aState : State) : Boolean =  
 (aState.region->size() > 1) and
       (not aState.region->select(r : Region | r.request_region_needs_exit())
             ->isEmpty()) /]

[query public request_state_needs_exit(aState : State): Boolean
 = (not aState.exit.oclIsUndefined()) 
    or aState.request_state_needs_region_exit() /]

[query public request_region_needs_exit(aRegion : Region): Boolean
 = not aRegion.subvertex->selectByKind(State)
    ->select(st : State | st.request_state_needs_exit())->isEmpty()/]

[query public request_region_event_states(aRegion:Region, anEvent:Event) 
  : OrderedSet(State) = 
    aRegion.request_region_states()
                       ->select(s:State|s.outgoing.trigger->flatten()
                                        .event->includes(anEvent)
      or s.region->collect(r:Region|r.request_region_events())
                 ->flatten()->includes(anEvent))/]

[query public request_region_needs_dispatch(aRegion : Region, anEvent : Event)
   : Boolean
 = let regionStates : OrderedSet(State) = aRegion.request_region_states() in
   let regionEvents : OrderedSet(Event) = null in
     false/]

[query public request_parent_exit_state(aState : State): State
 = if (not aState.container.oclIsUndefined())
       and (not aState.container.state.oclIsUndefined())
       and (not aState.container.state.isOrthogonal) then
      if aState.container.state.exit.oclIsUndefined() then
         aState.container.state.request_parent_exit_state()
      else
         aState.container.state
      endif
   else null endif/]

[query public request_event_subregions(aState: State, anEvent : Event)
  : OrderedSet(Region) = aState.region
           ->select(r:Region|r.request_region_events()->includes(anEvent))
           ->asOrderedSet()->sortedBy(r:Region|r.name.toLowerCase())/]

[query public request_else_transitions(transitions : OrderedSet(Transition))
       : OrderedSet(Transition) = transitions
                 ->select(t:Transition | not t.guard.oclIsUndefined() 
                           and t.guard.oclIsKindOf(Expression) 
                           and t.guard.oclAsType(Expression).symbol = 'else')/]
[**
 * @brief Returns The topmost state that should be exited to execute the 
 * transition.
 */]
[query public request_transition_exit_state(aTransition:Transition) : State
 = 
      let sourceHierarchy : OrderedSet(State) =
        aTransition.source.request_parent_states() in
      let targetHierarchy : OrderedSet(State) = 
        aTransition.target.request_parent_states()in
      let exitHierarchy : OrderedSet(State) =
        sourceHierarchy->removeAll(targetHierarchy) in
      if exitHierarchy->isEmpty() then 
      if aTransition.source.oclIsKindOf(State) 
         then aTransition.source.oclAsType(State) else null endif
      else exitHierarchy->first() endif/]

[**
 * @brief Returns a list of parent state with the top most state in the 
 * hierarchy as the first.
 * @param aVertex The vertex for which parent hierarchy should be returned 
 */]
[query public request_parent_states(aVertex:Vertex):OrderedSet(State) = 
 if aVertex.container.state.oclIsUndefined() then
    OrderedSet{}
 else
    aVertex.container.state.request_parent_states()
                            ->append(aVertex.container.state)
 endif/]

[**
 * @brief Get a list of states that will be exited when the transition occurs.
 * Does not include substates of a compound source state. 
 */]
[query public request_transition_exit_states(aTransition : Transition):
OrderedSet(State) = 
 let exitState : State = aTransition.request_transition_exit_state() in
 let parentStates : OrderedSet(State) = if exitState.oclIsUndefined() 
       then OrderedSet{} else if aTransition.source.oclIsKindOf(State) then
           aTransition.source.request_parent_states()
                          ->append(aTransition.source.oclAsType(State)) 
       else aTransition.source.request_parent_states() endif endif in
 if parentStates->isEmpty() 
          then OrderedSet{} else parentStates
                               ->drop(parentStates->indexOf(exitState)) endif /]

[query public request_transition_behaviors(aTransition : Transition) 
  : Sequence(Behavior) = 
   null/]

[query public request_state_machine_states(sm:StateMachine):OrderedSet(State) = 
 sm.eAllContents(State)->select(s:State|s.containingStateMachine() = sm)
    ->asOrderedSet()/]

[query public request_state_machine_transitions(sm:StateMachine):
  OrderedSet(Transition) = 
 sm.eAllContents(Transition)
    ->select(t:Transition|t.containingStateMachine() = sm)
    ->asOrderedSet()/]

[query public request_transition_effect_region(aTransition:Transition):
  Region = let exit_state : State = aTransition.request_transition_exit_state()
  in if not exit_state.oclIsUndefined() then exit_state.request_vertex_region()
  else aTransition.source.request_vertex_region() endif/]