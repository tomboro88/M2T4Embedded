[comment encoding = UTF-8 /]
[module packageCFile('http://www.eclipse.org/uml2/5.0.0/UML')]

[import tbo::acceleo::psm::uml::gen::c::common::utils /]
[import tbo::acceleo::psm::uml::gen::c::common::documentation /]
[import tbo::acceleo::psm::uml::gen::c::common::uml_c/]
[import tbo::acceleo::psm::uml::gen::c::request::request/]

[template public generatePackageC(aPackage : Package)
  {header_packages : Set(Package) = uml_c_header_subpackages(aPackage)->union(
   uml_c_header_dependencies(aPackage))->asSet();
   source_subpackages : Set(Package) = uml_c_source_subpackages(aPackage);
   source_dependencies  : Set(Package) = uml_c_source_dependencies(aPackage)
      ->removeAll(header_packages);
   sourceLiteralSpecifications : Sequence(LiteralSpecification) = 
    uml_c_source_literal_specifications(aPackage);
   allClassifiers : OrderedSet(Classifier) = 
      utils_sort_by_name(aPackage.request_non_packaged_children()
                         ->selectByKind(Classifier)).oclAsType(Classifier)
                         ->asOrderedSet();
   sourceClassifiers : OrderedSet(Classifier) = 
      utils_sort_by_name(aPackage.uml_c_source_classifiers())
              .oclAsType(Classifier)->asOrderedSet();
   needs_get_specific : Boolean = not allClassifiers->select(
       aClassifier : Classifier | aClassifier.request_needs_storage() 
       and not aClassifier.general->isEmpty())->isEmpty();
   general_extern_classifiers : OrderedSet(Classifier) = 
     allClassifiers.general->asOrderedSet()
                    ->select(c:Classifier|c._package <> aPackage);}]

[file (get_package_c_qualified_path(aPackage), false, 'UTF-8')]
[documentationCFile('The ' + aPackage.name + ' package source file.')/]

/*******************************************************************************
 * 
 * Include statements.
 * 
 ******************************************************************************/
//[protected('includes top')]
//[/protected]
#include "[get_package_h_filename(aPackage)/]"
[uml_c_include_dependencies(source_dependencies, source_subpackages, 0)
/][if needs_get_specific]
#include <stddef.h>
[/if][if needs_get_specific]
#include <stdint.h>
[/if][if needs_get_specific]
#include <stdbool.h>
[/if][if (not sourceClassifiers->selectByKind(StateMachine)->isEmpty())
    and aPackage.uml_c_header_classifiers()
        ->selectByKind(StateMachine)->isEmpty()]
#include <sm.h>
[/if]//[protected('includes bottom')]
//[/protected]
/*******************************************************************************
 *
 * Data type, constant, and macro definitions.
 *
 ******************************************************************************/
[if not sourceLiteralSpecifications
    ->select(ls : LiteralSpecification | ls.uml_c_literalspec_need_define())
    ->isEmpty() ]
[uml_c_literal_list(sourceLiteralSpecifications, 0)/]

[/if]
[if (not allClassifiers->select(
 aClassifier : Classifier | aClassifier.request_needs_storage() 
 and not aClassifier.general->isEmpty())->isEmpty())]
[documentation_string('@brief The macro used to initialize a pointer to the '
  + 'child class from a pointer to the base class.\n' 
  + documentation_param(ParameterDirectionKind::_in, 
               'child_type', 'The name of the child class type.') + '\n'
  + documentation_param(ParameterDirectionKind::_in, 
               'base_field', 'The name of the field of the base class.') + '\n'
  + documentation_param(ParameterDirectionKind::_in, 
               'child_ptr', 'The name of the child class target pointer.'), 0)/]
#define [aPackage.name.toUpper()
         /]_CHILD_FROM_BASE(child_type,base_field,child_ptr)\
        [aPackage.name/]_set_specific((char*)p_obj, \
                             offsetof(child_type,base_field), (char**)child_ptr)

[/if]
[if sourceClassifiers->uml_c_classifiers_need_declare()]
[uml_c_declare_structs(sourceClassifiers, 0)/]
[/if]
/*******************************************************************************
 * 
 * Non-private function prototypes.
 * 
 ******************************************************************************/
[if general_extern_classifiers
->uml_c_classifiers_operations_need_declaration(Set{VisibilityKind::protected})]
[uml_c_declare_operations(general_extern_classifiers, 
                          Set{VisibilityKind::protected}, true, 0)/]
[/if][if general_extern_classifiers
 ->uml_c_classifiers_behaviors_need_declaration(
                       Set{VisibilityKind::protected, VisibilityKind::public})]
[uml_c_declare_behaviors(
        general_extern_classifiers, 
        Set{VisibilityKind::protected, VisibilityKind::public}, true, 0)/]
[/if][if sourceClassifiers
   ->uml_c_classifiers_operations_need_declaration(Set{VisibilityKind::public})]
[uml_c_declare_operations(sourceClassifiers, 
                          Set{VisibilityKind::public}, false, 0)/]
[/if][if allClassifiers
 ->uml_c_classifiers_operations_need_declaration(Set{VisibilityKind::protected, 
                              VisibilityKind::_package})]
[uml_c_declare_operations(allClassifiers, 
                          Set{VisibilityKind::protected, 
                              VisibilityKind::_package}, false, 0)/]
[/if][if allClassifiers
 ->uml_c_classifiers_behaviors_need_declaration(Set{VisibilityKind::protected,
                                         VisibilityKind::_package,
                                         VisibilityKind::public})]
[uml_c_declare_behaviors(allClassifiers, Set{VisibilityKind::protected,
                                         VisibilityKind::_package,
                                         VisibilityKind::public}, false, 0)/]
[/if]
/*******************************************************************************
 * 
 * Private function prototypes.
 * 
 ******************************************************************************/
[if allClassifiers
  ->uml_c_classifiers_operations_need_declaration(Set{VisibilityKind::private})]
[uml_c_declare_operations(allClassifiers, 
                          Set{VisibilityKind::private}, false, 0)/]
[/if]
[if allClassifiers
 ->uml_c_classifiers_behaviors_need_declaration(Set{VisibilityKind::private})]
[uml_c_declare_behaviors(allClassifiers, Set{VisibilityKind::private}, 
                                       false, 0)/]
[/if]
[if not allClassifiers->select(c:Classifier | c.uml_c_needs_init_defaults())
    ->isEmpty()]
[uml_c_declare_defaults(allClassifiers, 0)/]
[/if]
[for (sm : StateMachine | allClassifiers->selectByKind(StateMachine)
      ->select(stm : StateMachine | not stm.request_all_orthogonal_regions()
                          ->select(r: Region | r.request_region_needs_exit())
                          ->isEmpty()))]
[uml_c_declare_region_exit(sm,0)/]
[/for]
[for (sm : StateMachine | allClassifiers->selectByKind(StateMachine)
      ->select(stm : StateMachine | not stm.request_all_orthogonal_regions()
                                    ->isEmpty()))]
[uml_c_declare_sm_dispatch(sm, 0)/]
[uml_c_declare_region_dispatch(sm,0)/]
[uml_c_declare_state_dispatch(sm, 0)/]
[/for]
/*******************************************************************************
 * 
 * Inline functions.
 * 
 ******************************************************************************/
[if (not allClassifiers->select(
 aClassifier : Classifier | aClassifier.request_needs_storage() 
 and not aClassifier.general->isEmpty())->isEmpty())]
/**
 * @brief Obtains the pointer to the specialized class from the pointer to
 * the base class.
 * @param ['['/]in[']'/] p_base The pointer to the base class object.
 * @param ['['/]in[']'/] base_offset The amount by which the p_base is offset 
 *     from the specific class pointer. Should be obtained using the 
 *     offsetof(specific_type, base_field_name) macro.
 * @param ['['/]out[']'/] pp_specific The pointer to the location where the 
 *     seeked pointer should be stored.
 * @return true if the searched pointer was found.
 */
static inline bool 
[aPackage.name/]_set_specific(char* const p_base, size_t const base_offset,
[utils_indent(aPackage.name.size())/]              char** const pp_specific)
{
    bool b_is_copied = false;

    if((NULL != pp_specific) && (NULL != p_base) 
            && (base_offset <= PTRDIFF_MAX))
    {
        *pp_specific = (&p_base['['/]-((ptrdiff_t)base_offset)[']'/]);
        b_is_copied = true;
    }

    return b_is_copied;
}

[/if]
[for (sm : StateMachine | allClassifiers->selectByKind(StateMachine))]
[uml_c_define_state_entry(sm,0)/]
[if not sm.eAllContents(State)
          ->select(aState : State | aState.request_state_needs_exit())
          ->isEmpty() ]
[uml_c_define_state_exit(sm,0)/]
[/if]
[/for]
/*******************************************************************************
 * 
 * Static data declarations.
 * 
 ******************************************************************************/
[uml_c_init_vtables(allClassifiers, 0)/]
/*******************************************************************************
 * 
 * Public function bodies.
 * 
 ******************************************************************************/
[if allClassifiers->uml_c_have_operations(Set{VisibilityKind::public})]
[uml_c_define_operations(allClassifiers, Set{VisibilityKind::public}, 0)/]
[/if]
[if allClassifiers
    ->request_have_virtual_behaviors(Set{VisibilityKind::public})]
[uml_c_define_behaviors(allClassifiers, Set{VisibilityKind::public}, 0)/]
[/if]
/*******************************************************************************
 * 
 * Non-public function bodies.
 * 
 ******************************************************************************/
[if not allClassifiers->select(c : Classifier | 
                     c.uml_c_needs_init_defaults())->isEmpty()]
[uml_c_define_defaults(allClassifiers,0)/]
[/if]
[if allClassifiers->uml_c_have_operations(Set{VisibilityKind::_package,
                                            VisibilityKind::private,
                                            VisibilityKind::protected})]
[uml_c_define_operations(allClassifiers, Set{VisibilityKind::_package,
                                            VisibilityKind::private,
                                            VisibilityKind::protected}, 0)/]
[/if]
[if allClassifiers
    ->request_have_virtual_behaviors(Set{VisibilityKind::_package,
                                            VisibilityKind::private,
                                            VisibilityKind::protected})]
[uml_c_define_behaviors(allClassifiers, Set{VisibilityKind::_package,
                                            VisibilityKind::private,
                                            VisibilityKind::protected}, 0)/]
[/if]
[for (sm : StateMachine | allClassifiers->selectByKind(StateMachine)
      ->select(stm : StateMachine | not stm.request_all_orthogonal_regions()
                          ->isEmpty()))]
[if not sm.request_all_orthogonal_regions()
                          ->select(r: Region | r.request_region_needs_exit())
                          ->isEmpty()]
[uml_c_define_region_exit(sm,0)/]
[/if]
[uml_c_implement_sm_dispatch(sm, 0)/]
[uml_c_implement_region_dispatch(sm,0)/]
[uml_c_implement_state_dispatch(sm, 0)/]
[/for]
/*** end of file ***/
[/file]
[/template]
