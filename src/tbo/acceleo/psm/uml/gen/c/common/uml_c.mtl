[comment encoding = UTF-8 /]
[module uml_c('http://www.eclipse.org/uml2/5.0.0/UML')]

[import tbo::acceleo::psm::uml::gen::c::common::documentation/]
[import tbo::acceleo::psm::uml::gen::c::common::utils/]
[import tbo::acceleo::psm::uml::gen::c::request::request/]

[query private uml_c_function_visibility(vis:VisibilityKind):String = 
if vis = VisibilityKind::private then 'static ' else '' endif/]

[**
 * Provides the type of the operation return value. 
 */]
[query private uml_c_operation_return_type(anOperation : Operation) : String = 
  if anOperation.type.oclIsUndefined() 
  then 'void' 
  else uml_c_parameter_type(request_return_value(anOperation)->first()) endif /]

[**
 * Provides the type of the behavior return value. 
 */]
[query private uml_c_behavior_return_type(aBehavior : Behavior) : String = 
  if aBehavior.specification.oclIsUndefined() or 
     not aBehavior.specification.oclIsKindOf(Operation) 
  then 'void' 
  else uml_c_operation_return_type(aBehavior.specification.oclAsType(Operation))
  endif /]

[**
 * This query decides if a parameter is passed by copy or by reference. 
 */]
[query private uml_c_param_by_ref(p : Parameter) : Boolean = 
    (not p.type.oclIsKindOf(DataType)) 
    or (p.direction = ParameterDirectionKind::inout)
    or (p.direction = ParameterDirectionKind::out)
    or (p.upper <> 0 and p.upper <> 1)
    or (p.lower = 0)/]

[**
 * This query forms a full parameter type specification string. 
 */]
[query private uml_c_parameter_type(p : Parameter) : String = 
    if uml_c_param_by_ref(p)
       and ((p.direction = ParameterDirectionKind::_in)
            or (p.direction = ParameterDirectionKind::return
                and p.effect = ParameterEffectKind::read)) 
    then 'const ' else '' endif + 
    uml_c_get_type_name(p.type) + 
    if uml_c_param_by_ref(p) then '*' else '' endif/]

[**
 * This query automatically provides the correct declaration of a parameter.
 */]
[query private uml_c_param_decl(p : Parameter) : String = 
    uml_c_param_decl(uml_c_parameter_type(p), p.name) /]

[**
 * This query specifies the format of function parameter declaration.
 */]
[query private uml_c_param_decl(type : String, name : String) : String = 
    type.trim() + ' const ' + name.trim() /]

[**
 * This query provides the declaration of the function self parameter.
 */]
[query private uml_c_parameter_self(o : Operation) : String = 
    uml_c_param_decl(if o.isQuery then 'const ' else '' endif 
          + o.featuringClassifier.uml_c_get_type_name()
          + '*', 'p_obj') /]

[**
 * Returns a sequence of strings representing parameters from the operation 
 * parameter list. 
 */]
[query private uml_c_param_strings(o:Operation) : Sequence(String) =
  if request_parameter_only(o)->isEmpty()
  then
    Sequence{if (not o.isStatic) 
    then uml_c_parameter_self(o) 
    else 'void'
    endif}
  else
    if (not o.isStatic)
    then 
      (request_parameter_only(o)->collect(p : Parameter|uml_c_param_decl(p))
         )->prepend(uml_c_parameter_self(o))
    else
      request_parameter_only(o)->collect(p : Parameter|uml_c_param_decl(p))
    endif
  endif /]

[**
 * This query checks if the parameter declaration will fit the specified width
 * after being splitted an the ' const ' token (Assumes the token is present).
 */]
[query private uml_c_fits_param_width(s : String, width : Integer) : 
 Boolean = 
 let index : Integer = s.lastIndex(' const ') in (
   (index-1) <= width and (s.size()-index)<=width)/]

[**
 * Concatenates the strings in the sequence so that each result string 
 * is no longer than the specified width.
 * @param aSequence The sequence of strings that should be concatenated.
 * @param width The sequence of width for each result string. If its number of 
 * elements is lower that the number of strings, the las width will be used for 
 * the rest of the strings.
 */]
[query private uml_c_concat_short_params(aSequence : Sequence(String), 
                                      width : Sequence(Integer))
 : Sequence(String) = 
 if aSequence->size() > 1 and width->size() > 0 then
   let joined_string : String = aSequence->at(1)+' '+ aSequence->at(2) in 
   if joined_string.size()<=(width->first())
   then uml_c_concat_short_params(aSequence->drop(2)->prepend(joined_string),
                                width)
   else aSequence->drop(1)->uml_c_concat_short_params(
         if width->size() > 1 
         then width->drop(1) 
         else width endif)->prepend(aSequence->first()) 
   endif
 else aSequence endif/]

[**
 * Splits the operation parameter declarations that are too long to fit the 
 * given width. 
 * @param aSequence The sequence of strings that should be splitted.
 * @param width The sequence of widths for each of the input eement. If the 
 * number of elements is lower than the number of strings, the last element
 * will b used for the remaining strings.
 */]
[query private uml_c_split_long_params(aSequence : Sequence(String), 
                                      width : Sequence(Integer))
 : Sequence(String) = 
 if aSequence->size() > 0 and width->size() > 0 then
   (let s : String = aSequence->at(1)
                    + if aSequence->size()>1 then ',' else '' endif in 
   if s.size()<=(width->first())
   then Sequence{s}
   else let index : Integer = s.lastIndex(' const ') in
        if index > 0 
        then Sequence{s.first(index),'/**/'+s.last(s.size()-index)}
        else Sequence{s}
        endif
   endif)->union(aSequence->drop(1)->uml_c_split_long_params(
         if width->size() > 1 
         then width->drop(1) 
         else width endif))
 else aSequence endif/]

[**
 * This query decides if a property is stored by copy or by reference. 
 */]
[query private uml_c_property_by_ref(p : Property) : Boolean = 
    (not (p.aggregation = AggregationKind::composite
      or p.type.oclIsKindOf(DataType)))
    or (p.aggregation = AggregationKind::shared)
    or (p.upper = *)
    or (p.lower = 0)/]

[**
 * Recognizes some of the common fixed size integer and floating point types
 * and replaces their names with names of appropriate c language types.
 */]
[query private uml_c_get_type_name(aType: Type) : String = 
 let n : String = aType.name.toLower() in
 let predefined : Set(String) = Set {'int8', 'uint8', 'int16', 'uint16', 
 'int32', 'uint32', 'int64', 'uint64', 'float32', 'float64', 'float128'} in
 if predefined->includes(n) then
    n + uml_c_get_type_suffix(aType)
 else
    if predefined->collect(s : String | s + uml_c_get_type_suffix(aType))
       ->includes(n) then
        n
    else
        if aType.oclIsKindOf(PrimitiveType) then
            n
        else
        uml_c_get_element_full_name(aType) + uml_c_get_type_suffix(aType)
        endif
    endif
 endif 
 /]

[**
 * This query forms a full property type specification string. 
 */]
[query private uml_c_property_type(p : Property) : String = 
    uml_c_get_type_name(p.type) + 
    if uml_c_property_by_ref(p) then '*' else '' endif/]

[**
 * Get all subpackages visible in the package header file. 
 */]
[query public uml_c_header_subpackages(aPackage:Package):Set(Package) =
    request_visible_subpackages(aPackage, uml_c_header_visibility())/]

[**
 * @brief Get all Package dependencies visible in the Package header file. 
 */]
[query public uml_c_header_dependencies(aPackage:Package):Set(Package) =
    request_visible_dependencies(aPackage, uml_c_header_visibility())/]

[**
 * Get all subpackages visible in the package source file. 
 */]
[query public uml_c_source_subpackages(aPackage:Package):Set(Package) =
      request_visible_subpackages(aPackage, uml_c_source_visibility())/]

[**
 * @brief Get all Package dependencies visible in the Package source file. 
 */]
[query public uml_c_source_dependencies(aPackage:Package):Set(Package) =
    request_visible_dependencies(aPackage, uml_c_source_visibility())/]

[query private uml_c_sort_classifiers(aSeq : Sequence(Classifier)) : 
  Sequence(Classifier)
  = if aSeq->size() <=1 then aSeq
    else 
      let aRest : Sequence(Classifier) = aSeq->drop(1) in
      let aFirst : Classifier = aSeq->first() in
      if aRest->exists(c:Classifier | 
        aFirst.attribute.type->includes(c.oclAsType(Type)))
      then aRest->uml_c_sort_classifiers()->append(aFirst)
      else aRest->uml_c_sort_classifiers()->prepend(aFirst)
      endif
    endif/]


[query public uml_c_header_visibility(traceabilityContext : OclAny) : 
      Set(VisibilityKind) = 
      Set{VisibilityKind::public, VisibilityKind::protected, 
      VisibilityKind::_package}/]

[query public uml_c_source_visibility(traceabilityContext : OclAny) : 
      Set(VisibilityKind) = 
      request_all_visibilities()->removeAll(uml_c_header_visibility())/]

[query public uml_c_header_operation_visibility(traceabilityContext : OclAny) :
      Set(VisibilityKind) = Set{VisibilityKind::public}/]

[query public uml_c_source_operation_visibility(traceabilityContext : OclAny) :
      Set(VisibilityKind) = request_all_visibilities()
      ->removeAll(uml_c_header_operation_visibility())/]

[**
 * @brief Returns a Sequence of namespaces that should b visible in a header
 * file if the input namespace itself should also be visible in the header.
 */]
[query public uml_c_header_namespaces(aNamespace:Namespace) : 
  Sequence(Namespace) = 
  if uml_c_header_visibility()->includes(aNamespace.visibility) 
  then aNamespace.eContents(Namespace).uml_c_header_namespaces()
  ->append(aNamespace)
  else Sequence{} endif/]

[**
 * @brief Returns a sequence of all namespaces that should be visible in 
 * the package header. 
 */]
[query public uml_c_pkg_header_namespaces(aPackage : Package) : 
   Sequence(Namespace) = 
      aPackage.request_direct_children()->selectByKind(Namespace)
      .uml_c_header_namespaces()/]
[**
 * Get a Sequence of classifiers that should be declared in the header file. 
 */]
[query public uml_c_header_classifiers(aPackage : Package): 
  Sequence(Classifier) = 
  let allClassifiers : Sequence(Classifier) = 
      aPackage.request_non_packaged_children()->selectByKind(Classifier) in
  let visibleNamespaces : Sequence(Namespace) = 
      aPackage.uml_c_pkg_header_namespaces() in
  let visibleClassifiers : Sequence(Classifier) = 
    visibleNamespaces->selectByKind(Classifier) in
    visibleClassifiers->union(visibleClassifiers.attribute.type
    ->selectByKind(Classifier)
    ->select(c:Classifier|allClassifiers->includes(c)))->asOrderedSet()
    ->asSequence()/]

[**
 * Get a Sequence of classifiers that should be declared in the source file. 
 */]
[query public uml_c_source_classifiers(aPackage : Package): 
  Sequence(Classifier) = 
  let allClassifiers : Sequence(Classifier) = 
      aPackage.request_non_packaged_children()->selectByKind(Classifier) in
  let headerClassifiers : Sequence(Classifier) = 
      uml_c_header_classifiers(aPackage) in
    allClassifiers->select(c:Classifier | 
    not headerClassifiers->includes(c))/]

[query public uml_c_is_visible_in_header(aPackage:Package, 
                                         aNamedElement : NamedElement) 
 : Boolean = 
 let anc : Sequence(NamedElement) = aNamedElement.ancestors(NamedElement) in
 aNamedElement.getNearestPackage() = aPackage and 
 anc->dropRight(anc->size() - anc->indexOf(aPackage.oclAsType(NamedElement))+1)
 ->prepend(aNamedElement)->collect(n:NamedElement|n.visibility)
 ->forAll(v : VisibilityKind | uml_c_header_visibility()->includes(v))/]

[query public uml_c_header_literal_specifications(aPackage : Package)
  : Sequence(LiteralSpecification) = 
  let headerProperties : Sequence(Property) 
      = uml_c_header_classifiers(aPackage).attribute in
  request_non_packaged_children(aPackage)->filter(LiteralSpecification)
  ->select(ls : LiteralSpecification | uml_c_is_visible_in_header(aPackage, ls)
  or ls.ancestors(Property)->exists(p:Property|headerProperties->includes(p)))/]

[query public uml_c_source_literal_specifications(aPackage : Package)
  : Sequence(LiteralSpecification) = 
  request_non_packaged_children(aPackage)->filter(LiteralSpecification)
  ->removeAll(uml_c_header_literal_specifications(aPackage))/]

[query public uml_c_get_type_suffix(aType:Type) : String 
= '_t'/]

[template public uml_c_get_literal_string(ls:LiteralSpecification)] 
[let lun : LiteralUnlimitedNatural = ls]
[lun.value/]u[elselet lr:LiteralReal = ls]
[lr.value/][elselet lb:LiteralBoolean = ls]
[lb.value/][elselet li:LiteralInteger = ls]
[li.value/][elselet lstr:LiteralString = ls]
[lstr.value/][else][/let]
[/template]

[**
 * Generate definitions of literals from the given sequence.
 */]
[template public uml_c_literal_list(
           aCollection:Collection(LiteralSpecification),indentation : Integer)]
[for (ls : LiteralSpecification | aCollection) 
         separator(utils_newline() + utils_newline())
         ?( (not ls.name->oclIsUndefined()) and (not ls.name->isEmpty()))]
[uml_c_literal_definition(ls,indentation)/][/for]
[/template]

[**
 * Includes a file.
 * @param aFile The string with the path to the file.
 * @param indentation The number of spaces the include directive should be 
 * indented. 
 */]
[template public uml_c_include_local_file(aFile : String, 
                                          indentation : Integer)]
#[indent(indentation)/]include "[aFile/]"
[/template]

[**
 * Includes a file.
 * @param aFile The string with the path to the file.
 * @param indentation The number of spaces the include directive should be 
 * indented. 
 */]
[template public uml_c_include_global_file(aFile : String, 
                                           indentation : Integer)]
#[indent(indentation)/]include <[aFile/]>
[/template]

[template public uml_c_include_dependencies(external_packages:Set(Package),
                                            sub_packages:Set(Package),
                                            indentation : Integer)]
[if (external_packages.name->includes('AnsiCLibrary'))]
[uml_c_include_global_file('stdint.h', indentation)/]
[/if]
[for (s : String | external_packages->reject(
   p:Package|p.name = 'AnsiCLibrary'
                )->removeAll(sub_packages).get_package_h_qualified_path())]
[uml_c_include_global_file(s, indentation)/]
[/for]
[for (s : String | sub_packages.get_package_h_path())]
[uml_c_include_local_file(s, indentation)/]
[/for]
[/template]
[**
 * Provides C declaration of a classifier.
 * @param aClassifier The classifier that should be declared.
 * @param indentation The number of spaces the declaration is indented from 
 * the left margin.
 */]
[template public uml_c_struct_decl(aClassifier : Classifier, 
                                  indentation : Integer)
  ?(aClassifier.request_needs_storage())
  {attr_indentation : Integer = getProperty('indent_width').toInteger();
   spaces : String = indent(attr_indentation);}]
[documentationElement(aClassifier,indentation)/]
typedef struct
{
[for (bC : Classifier | aClassifier.generalization.general->select(
          aC : Classifier | aC.request_needs_storage()))]
todo
[/for][for (p: Property | aClassifier.attribute)]
[spaces/][documentationElement(p,indentation + attr_indentation)/]
[spaces/][uml_c_property_decl(p,indentation + attr_indentation)/]
[/for]
} [uml_c_get_type_name(aClassifier)/];
[/template]

[template public uml_c_get_element_full_name(aNamedElement : NamedElement)
][aNamedElement.eContainer(Package).name + '_' + aNamedElement.name/][/template]

[template public uml_c_get_operation_full_name(anOperation : Operation)
][anOperation.eContainer(Package).name + '_' 
  + anOperation.featuringClassifier.name 
  + '_' + anOperation.name/][/template]

[template public uml_c_get_behavior_full_name(aBehavior : Behavior)
][aBehavior.eContainer(Package).name + '_' 
  + aBehavior._context.name 
  + '_' + aBehavior.name/][/template]

[template public uml_c_declare_structs(aSeq:Sequence(Classifier),
                                           indentation:Integer)
     {aSorted : Sequence(Classifier) = aSeq->uml_c_sort_classifiers();}]
[for (aClassifier : Classifier | aSorted)
 separator(utils_newline()+utils_newline())
 ?(aClassifier.request_needs_storage())]
[indent(indentation)/][uml_c_struct_decl(aClassifier, indentation)
/][/for]
[/template]

[**
 * Provides C declaration of an operation.
 * @param anOperation The operation that should be declared.
 * @param indentation The number of spaces the declaration is indented from 
 * left margin. 
 */]
[template public uml_c_operation_decl(anOperation : Operation,
                                        indentation : Integer)]
[uml_c_format_param_list(anOperation.visibility.uml_c_function_visibility() 
                         + uml_c_operation_return_type(anOperation) 
                         + ' ' + anOperation.uml_c_get_operation_full_name(),
                         uml_c_param_strings(anOperation),
                         indentation)/];
[/template]

[**
 * Provides C declaration of a Behavior.
 * @param aBehavior The Behavior that should be declared.
 * @param indentation The number of spaces the declaration is indented from 
 * left margin. 
 */]
[template public uml_c_behavior_decl(aBehavior : Behavior,
                                        indentation : Integer)]
[uml_c_format_param_list( aBehavior.visibility.uml_c_function_visibility()
     + aBehavior.uml_c_behavior_return_type() 
       + ' ' + aBehavior.uml_c_get_behavior_full_name(),
         uml_c_param_strings(aBehavior.specification.oclAsType(Operation)),
                         indentation)/];
[/template]

[**
 * Provides the C definition of an operation. 
 */]
[template public uml_c_operation_definition(anOperation : Operation,
                                      indentation : Integer)
    {indent_width : Integer = getProperty('indent_width').toInteger();}]
[documentationElement(anOperation,indentation)/]
[anOperation.visibility.uml_c_function_visibility() 
 + uml_c_operation_return_type(anOperation)/]
[uml_c_format_param_list(anOperation.name,
                                uml_c_param_strings(anOperation),indentation)/]
{
    [for (b: Behavior | anOperation.method)]
    [if (b.eGet('language')->includes('C'))]
    [let bd : String = b.eGet('body')->at(b.eGet('language')->indexOf('C'))]
[indent(indent_width)/][bd.indent_newlines(indent(indent_width))/]
    [/let]
    [/if]
    [/for]
}
[/template]

[**
 * Prints an Operation parameter list, preceded by a prefix string.
 * @param prefix The string that should be printed in the same line before the
 *     opening parenthesis.
 * @param aSequence The sequence of strings representing parameter declarations.
 * @param indentation The number of spaces the whole block is indented. 
 */]
[template private 
  uml_c_format_param_list(prefix : String, aSequence : Sequence(String),
                                 indentation : Integer)
  {line_width : Integer = getProperty('line_width').toInteger()
                          - indentation;
   line_sep : String = '\\'+utils_newline();
   alt_indent : Integer = 8;
   default_param_width: Integer = line_width-2-prefix.size();
   alt_param_width: Integer = line_width-1-alt_indent;
   b_fits_default_param_width : Boolean = aSequence->forAll(s:String 
                            | s.uml_c_fits_param_width(default_param_width));
   sep : String = if b_fits_default_param_width 
                  then line_sep + indent(prefix.size()+1)
                  else line_sep + indent(alt_indent)
                  endif;
   param_width : Integer = if b_fits_default_param_width 
                           then default_param_width
                           else alt_param_width
                           endif;
   b_prepend_linebreak : Boolean = if aSequence->notEmpty() 
              then not (b_fits_default_param_width 
                        or aSequence->first().size() <= default_param_width) 
              else false endif;
   first_param_width : Integer = if b_prepend_linebreak 
                                 then alt_param_width
                                 else default_param_width endif;
   width_sequence : Sequence(Integer) = Sequence{first_param_width,param_width};
   splitted : Sequence(String) = 
            aSequence->uml_c_split_long_params(width_sequence);
   grouped : Sequence(String) = 
            splitted->uml_c_concat_short_params(width_sequence);}]
[prefix
/][if (b_prepend_linebreak)][line_sep + indent(alt_indent-1)
/][/if]([for (s : String | grouped) separator(sep)][s/][/for])
[/template]

[**
 * This template forms a full property multiplicity specification string. 
 */]
[template private uml_c_property_multiplicity(p : Property)
    ?((p.upper <> *) and (p.upper <> 1) and (p.upper <> 0) and 
      (not p.upper.oclIsUndefined()))
    {name : String = if p.upperValue.name.oclIsUndefined() 
                     then '' else p.upperValue.name.trim() endif;
     b_is_literal : Boolean = (not p.upperValue.name.oclIsUndefined())
                               and (name.size() > 0)
                               and name.first(1).isAlpha();}]
['['/][if (b_is_literal)][name.toUpper()/][else][p.upper/][/if][']'/]
[/template]

[**
 * @brief Inserts a Property declaration string.
 * @param p The property that should be declared.
 * @param indentation How much the declaration is indented.
 */]
[template private uml_c_property_decl(p: Property, indentation : Integer) 
    {s : String = '                               ';
     t : String = p.uml_c_property_type();
     m : String = p.uml_c_property_multiplicity();
     sep : String = '\\' +utils_newline() + s + ' ';
     line_width : Integer = getProperty('line_width').toInteger() 
                          - indentation;}]
[t/][(if t.size() <= s.size() then s.substring(t.size()) 
      else ' '+sep
      endif)/][p.name/][if ((p.name.size() + m.size()+1)
                             >(line_width-s.size()-1))][sep/][/if][m/];
[/template]

[**
 * @brief Provides C declaration of an UML LiteralSpecification.
 */]
[template private uml_c_literal_definition(ls : LiteralSpecification,
                                          indentation : Integer) 
  ?(not (ls.name.oclIsUndefined() or ls.name.oclIsInvalid()))]
[indent(indentation)/][documentationElement(ls,indentation)/]
#[indent(indentation)/]define [ls.uml_c_get_element_full_name().toUpper()
                               /] [ls.uml_c_get_literal_string()/]
[/template]

[template public uml_c_declare_operations(aSeq:Sequence(Classifier),
                                          vis : Set(VisibilityKind), 
                                          indentation : Integer)]
[for (aClassifier : Classifier | aSeq) separator(utils_newline()) 
      ?(not aClassifier.ownedMember->filter(Operation)->isEmpty())]
[for (o: Operation | aClassifier.ownedMember->filter(Operation)
                     ->sortedBy(o:Operation|o.name.toLower()))
     ?(vis->includes(o.visibility))]
[indent(indentation)/][uml_c_operation_decl(o,indentation)/]
[/for]
[/for]
[/template]

[template public uml_c_declare_behaviors(aSeq:Sequence(Classifier),
                                          vis : Set(VisibilityKind), 
                                          indentation : Integer)]
[for (aClassifier : Classifier | aSeq) separator(utils_newline()) 
      ?(not aClassifier.ownedMember->filter(Behavior)->isEmpty())]
[for (b: Behavior | aClassifier.ownedMember->filter(Behavior)
                     ->sortedBy(b:Behavior|b.name.toLower()))
     ?(vis->includes(b.visibility) and (not b.specification.oclIsUndefined())
       and b.specification.oclIsKindOf(Operation))]
[indent(indentation)/][uml_c_behavior_decl(b,indentation)/]
[/for]
[/for]
[/template]

[**
 * Provides the C definition of a Behavior. 
 */]
[template public uml_c_behavior_definition(aBehavior : Behavior,
                                      indentation : Integer)
    {indent_width : Integer = getProperty('indent_width').toInteger();}]
[documentationElement(aBehavior,indentation)/]
[aBehavior.visibility.uml_c_function_visibility() 
 + aBehavior.uml_c_behavior_return_type()/]
[uml_c_format_param_list(aBehavior.uml_c_get_behavior_full_name(),
         uml_c_param_strings(aBehavior.specification.oclAsType(Operation)),
         indentation)/]
{
    [let ob : OpaqueBehavior = aBehavior]
    [if (ob.language->includes('C'))]
    [let bd : String = 
      let s : String = ob._body->at(ob.language->indexOf('C')) in 
                       if s.oclIsUndefined() then '' else s endif]
[indent(indent_width)/][bd.indent_newlines(indent(indent_width))/]
    [/let]
    [/if]
    [/let]
}
[/template]

[template public uml_c_define_behaviors(aSeq:Sequence(Classifier),
                                          vis : Set(VisibilityKind), 
                                          indentation : Integer)]
[for (aClassifier : Classifier | aSeq) separator(utils_newline()) 
      ?(not aClassifier.ownedMember->filter(Behavior)->isEmpty())]
[for (b: Behavior | aClassifier.ownedMember->filter(Behavior)
                     ->sortedBy(b:Behavior|b.name.toLower()))
     separator(utils_newline())
     ?(vis->includes(b.visibility) and (not b.specification.oclIsUndefined())
       and b.specification.oclIsKindOf(Operation))]
[indent(indentation)/][uml_c_behavior_definition(b,indentation)/]
[/for]
[/for]
[/template]