[comment encoding = UTF-8 /]
[module uml_c('http://www.eclipse.org/uml2/5.0.0/UML')]

[import tbo::acceleo::psm::uml::gen::c::common::documentation/]
[import tbo::acceleo::psm::uml::gen::c::common::utils/]
[import tbo::acceleo::psm::uml::gen::c::request::request/]

[query private uml_c_function_visibility(vis:VisibilityKind, 
                                         b_is_extern : Boolean):String = 
if b_is_extern then 'extern ' else
    if vis = VisibilityKind::private then 'static ' else '' endif 
endif/]

[**
 * Provides the type of the operation return value. 
 */]
[query private uml_c_operation_return_type(anOperation : Operation) : String = 
  if anOperation.type.oclIsUndefined()
  then 'void' 
  else uml_c_parameter_type(request_return_value(anOperation)->first()) endif /]

[**
 * Provides the type of the behavior return value. 
 */]
[query private uml_c_behavior_return_type(aBehavior : Behavior) : String = 
  if aBehavior.specification.oclIsUndefined() or 
     not aBehavior.specification.oclIsKindOf(Operation) 
  then 'void' 
  else uml_c_operation_return_type(aBehavior.specification.oclAsType(Operation))
  endif /]

[**
 * This query decides if a parameter is passed by copy or by reference. 
 */]
[query private uml_c_param_by_ref(p : Parameter) : Boolean = 
    (not p.type.oclIsKindOf(DataType)) 
    or (p.direction = ParameterDirectionKind::inout)
    or (p.direction = ParameterDirectionKind::out)
    or (p.upper <> 0 and p.upper <> 1)
    or (p.lower = 0)/]

[**
 * This query forms a full parameter type specification string. 
 */]
[query private uml_c_parameter_type(p : Parameter) : String = 
    if uml_c_param_by_ref(p)
       and ((p.direction = ParameterDirectionKind::_in)
            or (p.direction = ParameterDirectionKind::return
                and p.effect = ParameterEffectKind::read)) 
    then 'const ' else '' endif + 
    uml_c_get_type_name(p.type) + 
    if uml_c_param_by_ref(p) then '*' else '' endif/]

[**
 * This query automatically provides the correct declaration of a parameter.
 */]
[query private uml_c_param_decl(p : Parameter) : String = 
    uml_c_param_decl(uml_c_parameter_type(p), p.name) /]

[**
 * This query specifies the format of function parameter declaration.
 */]
[query private uml_c_param_decl(type : String, name : String) : String = 
    type.trim() + ' const ' + name.trim() /]

[**
 * This query provides the declaration of the function self parameter.
 */]
[query private uml_c_parameter_self(o : Operation) : String = 
    uml_c_param_decl(if o.isQuery then 'const ' else '' endif 
          + o.featuringClassifier.uml_c_get_type_name()
          + '*', utils_get_self_name()) /]

[**
 * Returns a sequence of strings representing argument from the operation 
 * parameter list. 
 */]
[query private uml_c_arg_strings(o:Operation) : Sequence(String) =
  if request_parameter_only(o)->isEmpty()
  then
    if (not o.isStatic) 
    then Sequence{utils_get_self_name(o)} 
    else Sequence{}
    endif
  else
    if (not o.isStatic)
    then 
      (request_parameter_only(o)->collect(p : Parameter|p.name)
         )->prepend(utils_get_self_name(o))
    else
      request_parameter_only(o)->collect(p : Parameter|p.name)
    endif
  endif /]

[**
 * Returns a sequence of strings representing parameters from the operation 
 * parameter list. 
 */]
[query private uml_c_param_strings(o:Operation) : Sequence(String) =
  if request_parameter_only(o)->isEmpty()
  then
    Sequence{if (not o.isStatic) 
    then uml_c_parameter_self(o) 
    else 'void'
    endif}
  else
    if (not o.isStatic)
    then 
      (request_parameter_only(o)->collect(p : Parameter|uml_c_param_decl(p))
         )->prepend(uml_c_parameter_self(o))
    else
      request_parameter_only(o)->collect(p : Parameter|uml_c_param_decl(p))
    endif
  endif /]

[**
 * This query checks if the parameter declaration will fit the specified width
 * after being splitted an the ' const ' token (Assumes the token is present).
 */]
[query private uml_c_fits_param_width(s : String, width : Integer) : 
 Boolean = 
 let index : Integer = s.lastIndex(' const ') in (
   (index-1) <= width and (s.size()-index)<=width)/]

[**
 * Concatenates the strings in the sequence so that each result string 
 * is no longer than the specified width.
 * @param aSequence The sequence of strings that should be concatenated.
 * @param width The sequence of width for each result string. If its number of 
 * elements is lower that the number of strings, the las width will be used for 
 * the rest of the strings.
 */]
[query private uml_c_concat_short_params(aSequence : Sequence(String), 
                                      width : Sequence(Integer))
 : Sequence(String) = 
 if aSequence->size() > 1 and width->size() > 0 then
   let joined_string : String = aSequence->at(1)+' '+ aSequence->at(2) in 
   if joined_string.size()<=(width->first())
   then uml_c_concat_short_params(aSequence->drop(2)->prepend(joined_string),
                                width)
   else aSequence->drop(1)->uml_c_concat_short_params(
         if width->size() > 1 
         then width->drop(1) 
         else width endif)->prepend(aSequence->first()) 
   endif
 else aSequence endif/]

[**
 * Splits the operation parameter declarations that are too long to fit the 
 * given width. 
 * @param aSequence The sequence of strings that should be splitted.
 * @param width The sequence of widths for each of the input eement. If the 
 * number of elements is lower than the number of strings, the last element
 * will b used for the remaining strings.
 */]
[query private uml_c_split_long_params(aSequence : Sequence(String), 
                                      width : Sequence(Integer))
 : Sequence(String) = 
 if aSequence->size() > 0 and width->size() > 0 then
   (let s : String = aSequence->at(1)
                    + if aSequence->size()>1 then ',' else '' endif in 
   if s.size()<=(width->first())
   then Sequence{s}
   else let index : Integer = s.lastIndex(' const ') in
        if index > 0 
        then Sequence{s.first(index),'/**/'+s.last(s.size()-index)}
        else Sequence{s}
        endif
   endif)->union(aSequence->drop(1)->uml_c_split_long_params(
         if width->size() > 1 
         then width->drop(1) 
         else width endif))
 else aSequence endif/]

[**
 * This query decides if a property is stored by copy or by reference. 
 */]
[query private uml_c_property_by_ref(p : Property) : Boolean = 
    (not (p.aggregation = AggregationKind::composite
      or p.type.oclIsKindOf(DataType)))
    or (p.aggregation = AggregationKind::shared)
    or (p.upper = *)
    or (p.lower = 0)/]

[**
 * Recognizes some of the common fixed size integer and floating point types
 * and replaces their names with names of appropriate c language types.
 */]
[query private uml_c_get_type_name(aType: Type) : String = 
 let n : String = aType.name.toLower() in
 let predefined : Set(String) = Set {'int8', 'uint8', 'int16', 'uint16', 
 'int32', 'uint32', 'int64', 'uint64', 'float32', 'float64', 'float128'} in
 if predefined->includes(n) then
    n + uml_c_get_type_suffix(aType)
 else
    if predefined->collect(s : String | s + uml_c_get_type_suffix(aType))
       ->includes(n) then
        n
    else
        if aType.oclIsKindOf(PrimitiveType) then
            n
        else
        uml_c_get_element_full_name(aType) + uml_c_get_type_suffix(aType)
        endif
    endif
 endif 
 /]

[**
 * Returns the name of the struct corresponding to the specific type.
 */]
[query private uml_c_get_struct_name(aType: Type) : String = 
 uml_c_get_element_full_name(aType) + uml_c_get_struct_suffix(aType)/]

[**
 * Returns the name of the struct corresponding to the virtual table 
 * of the specific type.
 */]
[query private uml_c_get_vtable_struct_name(aType: Type) : String = 
 uml_c_get_vtable_name(aType) + uml_c_get_struct_suffix(aType)/]

[**
 * Returns the name of the virtual table.
 */]
[query private uml_c_get_vtable_instance_name(aType : Type) : String = 
  uml_c_get_element_full_name(aType) + '_vtable'/]

[**
 * Returns the name of the struct corresponding to the virtual table 
 * of the specific type.
 */]
[query private uml_c_get_vtable_type_name(aType: Type) : String = 
 uml_c_get_vtable_name(aType) + uml_c_get_type_suffix(aType)/]

[**
 * Returns the name of the virtual table of the specific type.
 */]
[query private uml_c_get_vtable_name(aType: Type) : String = 
 uml_c_get_element_full_name(aType) + '_vt'/]

[**
 * This query forms a full property type specification string. 
 */]
[query private uml_c_property_type(p : Property) : String = 
    uml_c_get_type_name(p.type) + 
    if uml_c_property_by_ref(p) then '*' else '' endif/]

[**
 * Get all subpackages visible in the package header file. 
 */]
[query public uml_c_header_subpackages(aPackage:Package):Set(Package) =
    request_visible_subpackages(aPackage, uml_c_header_visibility())/]

[**
 * @brief Get all Package dependencies visible in the Package header file. 
 */]
[query public uml_c_header_dependencies(aPackage:Package):Set(Package) =
    request_visible_dependencies(aPackage, uml_c_header_visibility())/]

[**
 * Get all subpackages visible in the package source file. 
 */]
[query public uml_c_source_subpackages(aPackage:Package):Set(Package) =
      request_visible_subpackages(aPackage, uml_c_source_visibility())/]

[**
 * @brief Get all Package dependencies visible in the Package source file. 
 */]
[query public uml_c_source_dependencies(aPackage:Package):Set(Package) =
    request_visible_dependencies(aPackage, uml_c_source_visibility())
    ->removeAll(Set{aPackage})/]

[query public uml_c_header_visibility(traceabilityContext : OclAny) : 
      Set(VisibilityKind) = 
      Set{VisibilityKind::public, VisibilityKind::protected, 
      VisibilityKind::_package}/]

[query public uml_c_source_visibility(traceabilityContext : OclAny) : 
      Set(VisibilityKind) = 
      request_all_visibilities()->removeAll(uml_c_header_visibility())/]

[query public uml_c_header_operation_visibility(traceabilityContext : OclAny) :
      Set(VisibilityKind) = Set{VisibilityKind::public}/]

[query public uml_c_source_operation_visibility(traceabilityContext : OclAny) :
      Set(VisibilityKind) = request_all_visibilities()
      ->removeAll(uml_c_header_operation_visibility())/]

[**
 * @brief Returns a Sequence of namespaces that should b visible in a header
 * file if the input namespace itself should also be visible in the header.
 */]
[query public uml_c_header_namespaces(aNamespace:Namespace) : 
  Sequence(Namespace) = 
  if uml_c_header_visibility()->includes(aNamespace.visibility) 
  then aNamespace.eContents(Namespace).uml_c_header_namespaces()
  ->append(aNamespace)
  else Sequence{} endif/]

[**
 * @brief Returns a sequence of all namespaces that should be visible in 
 * the package header. 
 */]
[query public uml_c_pkg_header_namespaces(aPackage : Package) : 
   Sequence(Namespace) = 
      aPackage.request_direct_children()->selectByKind(Namespace)
      .uml_c_header_namespaces()/]
[**
 * Get a Sequence of classifiers that should be declared in the header file. 
 */]
[query public uml_c_header_classifiers(aPackage : Package): 
  Sequence(Classifier) = 
  let allClassifiers : Sequence(Classifier) = 
      aPackage.request_non_packaged_children()->selectByKind(Classifier) in
  let visibleNamespaces : Sequence(Namespace) = 
      aPackage.uml_c_pkg_header_namespaces() in
  let visibleClassifiers : Sequence(Classifier) = 
    visibleNamespaces->selectByKind(Classifier) in
    visibleClassifiers->union(visibleClassifiers.attribute.type
    ->selectByKind(Classifier)
    ->select(c:Classifier|allClassifiers->includes(c)))->asOrderedSet()
    ->asSequence()/]

[**
 * Get a Sequence of classifiers that should be declared in the source file. 
 */]
[query public uml_c_source_classifiers(aPackage : Package): 
  Sequence(Classifier) = 
  let allClassifiers : Sequence(Classifier) = 
      aPackage.request_non_packaged_children()->selectByKind(Classifier) in
  let headerClassifiers : Sequence(Classifier) = 
      uml_c_header_classifiers(aPackage) in
    allClassifiers->select(c:Classifier | 
    not headerClassifiers->includes(c))/]

[query public uml_c_is_visible_in_header(aPackage:Package, 
                                         aNamedElement : NamedElement) 
 : Boolean = 
 let anc : Sequence(NamedElement) = aNamedElement.ancestors(NamedElement) in
 aNamedElement.getNearestPackage() = aPackage and 
 anc->dropRight(anc->size() - anc->indexOf(aPackage.oclAsType(NamedElement))+1)
 ->prepend(aNamedElement)->collect(n:NamedElement|n.visibility)
 ->forAll(v : VisibilityKind | uml_c_header_visibility()->includes(v))/]

[query public uml_c_header_literal_specifications(aPackage : Package)
  : Sequence(LiteralSpecification) = 
  let headerProperties : Sequence(Property) 
      = uml_c_header_classifiers(aPackage).attribute in
  request_non_packaged_children(aPackage)->filter(LiteralSpecification)
  ->select(ls : LiteralSpecification | uml_c_is_visible_in_header(aPackage, ls)
  or ls.ancestors(Property)->exists(p:Property|headerProperties->includes(p)))/]

[query public uml_c_source_literal_specifications(aPackage : Package)
  : Sequence(LiteralSpecification) = 
  request_non_packaged_children(aPackage)->filter(LiteralSpecification)
  ->removeAll(uml_c_header_literal_specifications(aPackage))/]

[query public uml_c_get_type_suffix(aType:Type) : String 
= '_t'/]

[query public uml_c_get_struct_suffix(aType:Type) : String 
= '_s'/]

[query private uml_c_get_vtable_entry_name(anOperation : Operation) : String = 
 'p_' + anOperation.name/]

[query public uml_c_get_behavior_full_name(aBehavior : Behavior) : String = 
(if aBehavior.oclIsUndefined() then 'NULL' 
   else aBehavior.eContainer(Package).name + '_' + aBehavior._context.name 
   + '_' + aBehavior.name endif)/]

[query public uml_c_get_init_default_name(aClassifier : Classifier) : String 
  = uml_c_get_element_full_name(aClassifier) + '_init_df'/]

[query public uml_c_is_main_operation(anOperation : Operation) : Boolean  = 
    anOperation.name.toLower() = 'main' 
     and anOperation.featuringClassifier.getAppliedStereotypes()
         .name->includes('Focus')/]

[query public uml_c_operations_need_declaration(
          aClassifier : Classifier, vis : Set(VisibilityKind)) : 
 Set(Operation) = aClassifier.uml_c_get_operations(vis)
                ->select(o:Operation|not o.uml_c_is_main_operation()) /]

[query public uml_c_get_operations(
          aClassifier : Classifier, vis : Set(VisibilityKind)) : 
 Set(Operation) = aClassifier.ownedMember->filter(Operation)
                ->select(o:Operation|vis->includes(o.visibility)) /]

[query public uml_c_classifiers_operations_need_declaration(
           aSeq:Sequence(Classifier), vis : Set(VisibilityKind)) : Boolean
 = not aSeq->select(c:Classifier | 
    not c.uml_c_operations_need_declaration(vis)->isEmpty())->isEmpty()/]

[template public uml_c_get_literal_string(ls:LiteralSpecification)] 
[let lun : LiteralUnlimitedNatural = ls]
[lun.value/]u[elselet lr:LiteralReal = ls]
[lr.value/][elselet lb:LiteralBoolean = ls]
[lb.value/][elselet li:LiteralInteger = ls]
[li.value/][elselet lstr:LiteralString = ls]
"[lstr.value/]"[else]NULL[/let]
[/template]

[query public uml_c_literalspec_need_define(ls : LiteralSpecification)
 : Boolean = (not ls.name->oclIsUndefined()) and (not ls.name->isEmpty())/]

[**
 * Generate definitions of literals from the given sequence.
 */]
[template public uml_c_literal_list(
           aCollection:Collection(LiteralSpecification),indentation : Integer)]
[for (ls : LiteralSpecification | aCollection) 
         separator(utils_newline() + utils_newline())
         ?( ls.uml_c_literalspec_need_define())]
[uml_c_literal_definition(ls,indentation)/][/for]
[/template]

[**
 * Includes a file.
 * @param aFile The string with the path to the file.
 * @param indentation The number of spaces the include directive should be 
 * indented. 
 */]
[template public uml_c_include_local_file(aFile : String, 
                                          indentation : Integer)]
#[utils_indent(indentation)/]include "[aFile/]"
[/template]

[**
 * Includes a file.
 * @param aFile The string with the path to the file.
 * @param indentation The number of spaces the include directive should be 
 * indented. 
 */]
[template public uml_c_include_global_file(aFile : String, 
                                           indentation : Integer)]
#[utils_indent(indentation)/]include <[aFile/]>
[/template]

[template public uml_c_include_dependencies(external_packages:Set(Package),
                                            sub_packages:Set(Package),
                                            indentation : Integer)]
[if (external_packages.name->includes('AnsiCLibrary'))]
[uml_c_include_global_file('stdint.h', indentation)/]
[/if]
[for (s : String | external_packages->reject(
   p:Package|p.name = 'AnsiCLibrary'
                )->removeAll(sub_packages).get_package_h_qualified_path())]
[uml_c_include_global_file(s, indentation)/]
[/for]
[for (s : String | sub_packages.get_package_h_path())]
[uml_c_include_local_file(s, indentation)/]
[/for]
[/template]

[**
 * Provides the definition of the type associated with a given struct.
*/]
[template public uml_c_struct_typedef(aClassifier : Classifier, 
                                      indentation : Integer)
          ?(aClassifier.request_needs_storage())]
[uml_c_struct_typedef_string('@brief The type representing the ' 
  + uml_c_get_struct_name(aClassifier) + ' struct.', 
    uml_c_get_struct_name(aClassifier), uml_c_get_type_name(aClassifier), 
    indentation)/]
[/template]

[**
 * Provides the definition of the type associated with a given struct.
*/]
[template public uml_c_struct_typedef_string(doc : String,
                                      s_name : String,
                                      t_name : String, 
                                      indentation : Integer)]
[documentation_string(doc, indentation)/]
typedef struct [s_name/] \
        [t_name/];
[/template]

[**
 * Provides C declaration of a classifier.
 * @param aClassifier The classifier that should be declared.
 * @param indentation The number of spaces the declaration is indented from 
 * the left margin.
 */]
[template public uml_c_struct_decl(aClassifier : Classifier, 
                                  indentation : Integer)
  ?(aClassifier.request_needs_storage())
  {spaces : String = utils_get_indent_string();
   total_indentation : Integer = indentation + spaces.size();}]
[documentationElement(aClassifier,indentation)/]
struct [uml_c_get_struct_name(aClassifier)/]
{
[for (bC : Classifier | aClassifier.generalization.general->select(
          aC : Classifier | aC.request_needs_storage())
          ->sortedBy(aC : Classifier | aC.name.toLower()))]
[spaces/][documentation_string('@brief ' + bC.name + ' base class data.', 
                                total_indentation)/]
[spaces/][uml_c_property_decl_string(bC.uml_c_get_type_name(),bC.name,'',
                                     total_indentation)/]
[/for][for (p: Property | aClassifier.attribute)]
[spaces/][documentationElement(p,total_indentation)/]
[spaces/][uml_c_property_decl(p,total_indentation)/]
[/for][if (aClassifier.request_has_virtual_operations())]
[spaces/][documentation_string('@brief The pointer to the virtual table of the ' 
                               + aClassifier.name + ' class.', 
                                total_indentation)/]
[spaces/][uml_c_property_decl_string('const ' 
     + aClassifier.uml_c_get_vtable_type_name()+'*',utils_get_vtable_name(),'',
                                     total_indentation)/]
[/if]
};
[/template]

[**
 * Provides C declaration of a virtual table struct.
 * @param aClassifier The classifier which the virtual table should be 
 * declared for.
 * @param indentation The number of spaces the declaration is indented from 
 * the left margin.
 */]
[template public uml_c_vtable_decl(aClassifier : Classifier, 
                                  indentation : Integer)
  ?(aClassifier.request_needs_vtable())
  {spaces : String = utils_get_indent_string();
   total_indentation : Integer = indentation + spaces.size();}]
[documentation_string('@brief The virtual table struct for the ' 
  + uml_c_get_struct_name(aClassifier) + ' struct.' + 
  ' Contains pointers to all virtual methods of the class.', indentation)/]
struct [uml_c_get_vtable_struct_name(aClassifier)/]
{
[for (bC : Classifier | aClassifier.generalization.general->select(
          aC : Classifier | aC.request_needs_storage())
          ->sortedBy(aC : Classifier | aC.name.toLower()))]
[spaces/][documentation_string(bC.name + ' base class virtual table.', 
                                total_indentation)/]
[spaces/][uml_c_property_decl_string(bC.uml_c_get_vtable_type_name(),
              bC.name,'', total_indentation)/]
[/for][for (op: Operation | aClassifier.request_virtual_operations())]
[spaces/][documentationElement(op,total_indentation)/]
[spaces/][uml_c_operation_vpointer_decl(op,total_indentation+1)/];
[/for]
};
[/template]

[template public uml_c_get_element_full_name(aNamedElement : NamedElement)
][aNamedElement.eContainer(Package).name + '_' + aNamedElement.name/][/template]

[template public uml_c_get_operation_full_name(anOperation : Operation)
][(if anOperation.uml_c_is_main_operation() then
  '' else anOperation.eContainer(Package).name + '_' 
  + anOperation.featuringClassifier.name 
  + '_' endif + anOperation.name)/][/template]

[query public uml_c_classifiers_need_declare(aSeq:Sequence(Classifier))
 : Boolean = not aSeq->select(c:Classifier | c.request_needs_storage())
             ->isEmpty()/]

[template public uml_c_declare_structs(aSeq:Sequence(Classifier),
                                           indentation:Integer)
     ?(aSeq->uml_c_classifiers_need_declare())
     {aSorted : Sequence(Classifier) = aSeq->request_sort_classifiers();}]
[for (aClassifier : Classifier | aSorted)
 separator(utils_newline()+utils_newline())
 after(utils_newline()+utils_newline())
 ?(aClassifier.request_needs_storage())]
[if aClassifier.request_needs_vtable()]
[utils_indent(indentation)/][uml_c_struct_typedef_string(
       '@brief The virtual table type for the ' 
       + uml_c_get_struct_name(aClassifier) + ' struct.', 
       aClassifier.uml_c_get_vtable_struct_name(), 
       aClassifier.uml_c_get_vtable_type_name(), indentation)/]

[/if][utils_indent(indentation)/][uml_c_struct_typedef(aClassifier, indentation)
/][/for][for (aClassifier : Classifier | aSorted)
 separator(utils_newline())
 ?(aClassifier.request_needs_storage())]
[utils_indent(indentation)/][uml_c_struct_decl(aClassifier, indentation)/]
[if aClassifier.request_needs_vtable()]

[utils_indent(indentation)/][uml_c_vtable_decl(aClassifier, indentation)/]
[/if][/for]
[/template]

[template private uml_c_get_vtable_qualified_entry(aSeq : Sequence(String), 
                                                   indentation : Integer,
                                                   position : Integer)
 {entry_width : Integer = getProperty('line_width').toInteger()-indentation
                             -3;}]
[utils_query_nested_field(aSeq, entry_width, utils_get_max_name_length() + 1,
 position)/]
[/template]

[template public uml_c_init_vtable(aContext : Classifier,
                                   aTree : Sequence(Classifier),
                                    indentation : Integer)
    ?((not aContext.oclIsUndefined()) and (aTree->size() >= 1))
    {aTop : Classifier = aTree->last();
     spaces : String = utils_get_indent_string();}]
[for (bC : Classifier | aTop.generalization.general->select(
          aC : Classifier | aC.request_needs_storage())
      ->sortedBy(aC : Classifier | aC.name.toLower()))
      separator(','+utils_newline()) 
      after( if aTop.request_virtual_operations()->isEmpty() 
             then '' else ',' + utils_newline() endif)]
[aContext.uml_c_init_vtable(aTree->append(bC), indentation)
/][/for][for (op: Operation | aTop.request_virtual_operations())
           separator(','+utils_newline())][
spaces/][aTree->drop(1)->collect(c : Classifier | '.' + c.name)->append(
          '.' + uml_c_get_vtable_entry_name(op))
         ->uml_c_get_vtable_qualified_entry(indentation+spaces.size(),0)/] = [
    request_method_from_context(aTree,op).uml_c_get_behavior_full_name()
    /][/for][/template]

[template public uml_c_init_vtables(aClSeq : Sequence(Classifier),
                                    indentation : Integer)
 {spaces : String = utils_get_indent_string();
   total_indentation : Integer = indentation + spaces.size();}]
[for (aClassifier : Classifier | aClSeq) separator(utils_newline())
 ?(aClassifier.request_needs_vtable() and 
   not aClassifier.oclIsKindOf(Interface))]
[documentation_string('@brief The initialized virtual table for the ' 
  + uml_c_get_struct_name(aClassifier) + ' struct.', indentation)/]
static const [uml_c_get_vtable_type_name(aClassifier)
/] [uml_c_get_vtable_instance_name(aClassifier)/] = 
{
[aClassifier.uml_c_init_vtable(Sequence{aClassifier}, indentation)/]
};
[/for]
[/template]

[**
 * Provides C declaration of an operation.
 * @param anOperation The operation that should be declared.
 * @param b_is_extern If true the operation should be declared as extern.
 * @param indentation The number of spaces the declaration is indented from 
 * left margin. 
 */]
[template public uml_c_operation_decl(anOperation : Operation,
                                      b_is_extern : Boolean,
                                        indentation : Integer)]
[uml_c_format_param_list(
                 anOperation.visibility.uml_c_function_visibility(b_is_extern) 
                         + uml_c_operation_return_type(anOperation) 
                         + ' ' + anOperation.uml_c_get_operation_full_name(),
                         uml_c_param_strings(anOperation),
                         indentation+1)/];
[/template]

[**
 * Provides C declaration of an operation.
 * @param anOperation The operation that should be declared.
 * @param indentation The number of spaces the declaration is indented from 
 * left margin. 
 */]
[template public uml_c_operation_vpointer_decl(anOperation : Operation,
                                        indentation : Integer)]
[uml_c_format_param_list(uml_c_operation_return_type(anOperation) 
                      + ' (*' + uml_c_get_vtable_entry_name(anOperation)+')',
                      uml_c_param_strings(anOperation),
                      indentation)/]
[/template]

[**
 * Provides C declaration of a Behavior.
 * @param aBehavior The Behavior that should be declared.
 * @param indentation The number of spaces the declaration is indented from 
 * left margin. 
 */]
[template public uml_c_behavior_decl(aBehavior : Behavior, 
                                     b_is_extern : Boolean,
                                        indentation : Integer)]
[uml_c_format_param_list( 
     aBehavior.visibility.uml_c_function_visibility(b_is_extern)
     + aBehavior.uml_c_behavior_return_type() 
       + ' ' + aBehavior.uml_c_get_behavior_full_name(),
         uml_c_param_strings(aBehavior.specification.oclAsType(Operation)),
                         indentation)/];
[/template]

[**
 * Provides the C definition of an operation. 
 */]
[template public uml_c_operation_definition(anOperation : Operation,
                                      indentation : Integer)
    {indent_width : Integer = getProperty('indent_width').toInteger();
     prefix : String = utils_indent(indent_width) 
         + if (not anOperation.request_return_value()->isEmpty()) 
           then 'return ' else '' endif;}]
[documentationElement(anOperation,indentation)/]
[anOperation.visibility.uml_c_function_visibility(false) 
 + uml_c_operation_return_type(anOperation)/]
[uml_c_format_param_list(anOperation.uml_c_get_operation_full_name(),
                                uml_c_param_strings(anOperation),indentation)/]
{
    [if anOperation.request_is_virtual_operation()]
[utils_indent(indent_width)/]if((NULL != [utils_get_self_name()/]) && (NULL != [
                           utils_get_self_name()/]->[utils_get_vtable_name()/]))
[utils_indent(indent_width)/]{
[utils_indent(indent_width*2)/][uml_c_operation_vpointer_decl(anOperation, 
 (indent_width*2)+indentation)/]
[utils_indent(indent_width*3)/]= [utils_get_self_name()/]->[
 utils_get_vtable_name()/]->[uml_c_get_vtable_entry_name(anOperation)/];

[utils_indent(indent_width*2)/]if(NULL != [
                                    uml_c_get_vtable_entry_name(anOperation)/])
[utils_indent(indent_width*2)/]{
[utils_indent(indent_width*2)/][prefix/][
             uml_c_format_param_list(uml_c_get_vtable_entry_name(anOperation),
             uml_c_arg_strings(anOperation),
             indentation + prefix.size() + (indent_width*2) + 1)/];
[utils_indent(indent_width*2)/]}
[utils_indent(indent_width)/]}
    [else]
    [for (b: Behavior | anOperation.method
               ->select(b:Behavior|anOperation.featuringClassifier
                         ->includes(b._context.oclAsType(Classifier))))]
[prefix/][uml_c_format_param_list(b.uml_c_get_behavior_full_name(),
             uml_c_arg_strings(anOperation),indentation + prefix.size() + 1)/];
    [/for]
    [/if]
}
[/template]

[**
 * Prints an Operation parameter list, preceded by a prefix string.
 * @param prefix The string that should be printed in the same line before the
 *     opening parenthesis.
 * @param aSequence The sequence of strings representing parameter declarations.
 * @param indentation The number of spaces the whole block is indented. 
 */]
[template private 
  uml_c_format_param_list(prefix : String, aSequence : Sequence(String),
                                 indentation : Integer)
  {line_width : Integer = getProperty('line_width').toInteger()
                          - indentation;
   line_sep : String = '\\'+utils_newline();
   alt_indent : Integer = 8;
   default_param_width: Integer = line_width-2-prefix.size();
   alt_param_width: Integer = line_width-1-alt_indent;
   b_fits_default_param_width : Boolean = aSequence->forAll(s:String 
                            | s.uml_c_fits_param_width(default_param_width));
   sep : String = if b_fits_default_param_width 
                  then line_sep + utils_indent(prefix.size()+1)
                  else line_sep + utils_indent(alt_indent)
                  endif;
   param_width : Integer = if b_fits_default_param_width 
                           then default_param_width
                           else alt_param_width
                           endif;
   b_prepend_linebreak : Boolean = if aSequence->notEmpty() 
              then not (b_fits_default_param_width 
                        or aSequence->first().size() <= default_param_width) 
              else false endif;
   first_param_width : Integer = if b_prepend_linebreak 
                                 then alt_param_width
                                 else default_param_width endif;
   width_sequence : Sequence(Integer) = Sequence{first_param_width,param_width};
   splitted : Sequence(String) = 
            aSequence->uml_c_split_long_params(width_sequence);
   grouped : Sequence(String) = 
            splitted->uml_c_concat_short_params(width_sequence);}]
[prefix
/][if (b_prepend_linebreak)][line_sep + utils_indent(alt_indent-1)
/][/if]([for (s : String | grouped) separator(sep)][s/][/for])
[/template]

[**
 * This template forms a full property multiplicity specification string. 
 */]
[template private uml_c_property_multiplicity(p : Property)
    ?((p.upper <> *) and (p.upper <> 1) and (p.upper <> 0) and 
      (not p.upper.oclIsUndefined()))
    {name : String = if p.upperValue.name.oclIsUndefined() 
                     then '' else p.upperValue.name.trim() endif;
     b_is_literal : Boolean = (not p.upperValue.name.oclIsUndefined())
                               and (name.size() > 0)
                               and name.first(1).isAlpha();}]
['['/][if (b_is_literal)][name.toUpper()/][else][p.upper/][/if][']'/]
[/template]

[**
 * @brief Inserts a Property declaration string.
 * @param p The property that should be declared.
 * @param indentation How much the declaration is indented.
 */]
[template private uml_c_property_decl(p: Property, indentation : Integer) 
    {t : String = p.uml_c_property_type();
     m : String = p.uml_c_property_multiplicity();}]
[uml_c_property_decl_string(t,p.name,m,indentation)/]
[/template]

[**
 * @brief Inserts a Property declaration string.
 * @param t The type String.
 * @param n The name Sring.
 * @param m The multiplicity string.
 * @param indentation How much the declaration is indented.
 */]
[template private uml_c_property_decl_string(t:String, n:String, m:String,
                                             indentation : Integer) 
    {s : String = '                               ';
     sep : String = '\\' +utils_newline() + s + ' ';
     line_width : Integer = getProperty('line_width').toInteger() 
                          - indentation;}]
[t/][(if t.size() <= s.size() then s.substring(t.size()) 
      else ' '+sep
      endif)/][n/][if ((n.size() + m.size()+1)
                             >(line_width-s.size()-1))][sep/][/if][m/];
[/template]

[**
 * @brief Provides C declaration of an UML LiteralSpecification.
 */]
[template private uml_c_literal_definition(ls : LiteralSpecification,
                                          indentation : Integer) 
  ?(not (ls.name.oclIsUndefined() or ls.name.oclIsInvalid()))]
[utils_indent(indentation)/][documentationElement(ls,indentation)/]
#[utils_indent(indentation)/]define [ls.uml_c_get_element_full_name().toUpper()
                               /] [ls.uml_c_get_literal_string()/]
[/template]

[template public uml_c_declare_operations(aSeq:Sequence(Classifier),
                                          vis : Set(VisibilityKind), 
                                          b_is_extern : Boolean,
                                          indentation : Integer)
 ?(aSeq->uml_c_classifiers_operations_need_declaration(vis))]
[for (aClassifier : Classifier | aSeq) separator(utils_newline()) 
      ?(not aClassifier.uml_c_operations_need_declaration(vis)
                ->isEmpty())]
[for (o: Operation | aClassifier.uml_c_operations_need_declaration(vis)
                     ->sortedBy(o:Operation|o.name.toLower()))]
[utils_indent(indentation)/][uml_c_operation_decl(o, b_is_extern, indentation)/]
[/for]
[/for]
[/template]

[query public uml_c_behaviors_need_declaration(aClassifier : Classifier,
                                    vis : Set(VisibilityKind)) : Set(Behavior)
 = aClassifier.request_behaviors()
        ->select(b : Behavior | b.request_has_operation_spec(vis))/]

[query public uml_c_classifiers_behaviors_need_declaration(
       aSeq : Sequence(Classifier), vis : Set(VisibilityKind)) : Boolean
 = not aSeq->select(aClassifier : Classifier | 
       not aClassifier.uml_c_behaviors_need_declaration(vis)->isEmpty())
   ->isEmpty()/]

[template public uml_c_declare_behaviors(aSeq:Sequence(Classifier),
                                          vis : Set(VisibilityKind),
                                          b_is_extern : Boolean, 
                                          indentation : Integer)
?(aSeq->uml_c_classifiers_behaviors_need_declaration(vis))]
[for (aClassifier : Classifier | aSeq) separator(utils_newline()) 
      ?(not aClassifier.uml_c_behaviors_need_declaration(vis)->isEmpty())]
[for (b: Behavior | aClassifier.uml_c_behaviors_need_declaration(vis)
                     ->sortedBy(b:Behavior|b.name.toLower()))]
[utils_indent(indentation)/][uml_c_behavior_decl(b,b_is_extern, indentation)/]
[/for]
[/for]
[/template]

[**
 * Provides the C definition of a Behavior. 
 */]
[template public uml_c_behavior_definition(aBehavior : Behavior,
                                      indentation : Integer)]
[documentationElement(aBehavior,indentation)/]
[aBehavior.visibility.uml_c_function_visibility(false) 
 + aBehavior.uml_c_behavior_return_type()/]
[uml_c_format_param_list(aBehavior.uml_c_get_behavior_full_name(),
         uml_c_param_strings(aBehavior.specification.oclAsType(Operation)),
         indentation)/]
{
[uml_c_implement_behavior(aBehavior,'C',indentation)/]
}
[/template]

[template public uml_c_implement_behavior(aBehavior : Behavior, 
                             language : String, indentation : Integer)
 {indent_width : Integer = getProperty('indent_width').toInteger();}]
    [let ob : OpaqueBehavior = aBehavior]
    [if (ob.language->includes(language))]
    [let bd : String = 
      let s : String = ob._body->at(ob.language->indexOf(language)) in 
                       if s.oclIsUndefined() then '' else s endif]
[utils_indent(indent_width)/][bd.indent_newlines(utils_indent(indent_width))
/][/let]
    [/if]
    [/let]
[/template]

[template public uml_c_define_behaviors(aSeq:Sequence(Classifier),
                                          vis : Set(VisibilityKind), 
                                          indentation : Integer)]
[for (aClassifier : Classifier | aSeq) separator(utils_newline()) 
      ?(not aClassifier.request_operation_behaviors(vis)->isEmpty())]
[for (b: Behavior | aClassifier.request_operation_behaviors(vis)
                     ->sortedBy(b:Behavior|b.name.toLower()))
     separator(utils_newline())]
[utils_indent(indentation)/][uml_c_behavior_definition(b,indentation)/]
[/for]
[/for]
[/template]

[query public uml_c_needs_init_defaults(c : Classifier) : Boolean = 
 ( not c.attribute->select(p : Property | 
        not p.defaultValue->oclIsUndefined())->isEmpty())
       or (c.request_needs_vtable() and (not c.oclIsKindOf(Interface)))/]

[template public uml_c_declare_defaults(aSeq:Sequence(Classifier),
                                       indentation : Integer) ]
[for (aClassifier : Classifier | 
      aSeq->select(c : Classifier | c.uml_c_needs_init_defaults()))]
[utils_indent(indentation)/][uml_c_format_param_list('static void ' 
                         + aClassifier.uml_c_get_init_default_name(),
                         Sequence{
                            uml_c_param_decl(aClassifier.uml_c_get_type_name()
                                             + '*', utils_get_self_name())
                         },
                         indentation+1)/];
[/for]
[/template]

[template public uml_c_define_defaults(aSeq:Sequence(Classifier),
                                       indentation : Integer)
 {indent_width : Integer = getProperty('indent_width').toInteger();
  right_length : Integer = getProperty('line_width').toInteger()
                              -(indentation + indent_width 
                                + utils_get_max_name_length() + 6);}]
[for (aClassifier : Classifier | 
      aSeq->select(c : Classifier | c.uml_c_needs_init_defaults())) 
      separator(utils_newline())]
[utils_indent(indentation)
/][documentation_string('@brief The initializer function of the default values '
  + 'and virtual tables of the ' 
  + uml_c_get_struct_name(aClassifier) + ' struct.\n' 
  + documentation_param(ParameterDirectionKind::_in, 
               utils_get_self_name(), 'The pointer to the self object.'), 
  indentation)/]
[utils_indent(indentation)/]static void
[utils_indent(indentation)/][uml_c_format_param_list(
                               aClassifier.uml_c_get_init_default_name(),
                         Sequence{
                            uml_c_param_decl(aClassifier.uml_c_get_type_name()
                                             + '*', utils_get_self_name())
                         },
                         indentation)/]
[utils_indent(indentation)/]{
[for (p: Property | aClassifier.attribute->select(p : Property | 
        not p.defaultValue.oclIsUndefined()))]
[utils_indent(indent_width + indentation)/][
          Sequence{utils_get_self_name(), '->' + p.name}
          ->uml_c_get_vtable_qualified_entry(indentation+indent_width,0)
/] = [if p.defaultValue.name.oclIsUndefined() or p.defaultValue.name->isEmpty()
     ][let ls:LiteralSpecification = p.defaultValue
     ][ls.uml_c_get_literal_string()/][/let][else][
              p.defaultValue.uml_c_get_element_full_name().toUpper()/][/if];
[/for][if aClassifier.request_needs_vtable()]
[utils_indent(indent_width + indentation)
/][uml_c_assign_vtable(Sequence{aClassifier}, indent_width + indentation)/]
[/if]
[utils_indent(indentation)/]}
[/for]
[/template]

[template public uml_c_assign_vtable(aTree : Sequence(Classifier),
                                    indentation : Integer)
    ?((aTree->size() >= 1) and (not aTree->first().oclIsUndefined()))
    {aContext:Classifier = aTree->first();
     aTop : Classifier = aTree->last();
     h : Sequence(String) = aTree->drop(1)->collect(c : Classifier | c.name);
     right_length : Integer = getProperty('line_width').toInteger()
                              -(indentation
                                + utils_get_max_name_length() + 6);}]
[for (bC : Classifier | aTop.generalization.general->select(
          aC : Classifier | aC.request_needs_vtable())
      ->sortedBy(aC : Classifier | aC.name.toLower()))
      separator(utils_newline()) 
      after( if aTop.request_virtual_operations()->isEmpty() 
             then '' else utils_newline() endif)]
[uml_c_assign_vtable(aTree->append(bC), indentation)
/][/for][if aTop.request_has_virtual_operations()][
  (let h_vt : Sequence(String) = h->append(utils_get_vtable_name()) 
   in h_vt->drop(1)->collect(s:String | '.' + s )
   ->prepend('->' + h_vt->first())->prepend(utils_get_self_name())
         ->uml_c_get_vtable_qualified_entry(indentation,0))/] = &[
   h->collect(s:String|'.'+s)->prepend(uml_c_get_vtable_instance_name(aContext))
   ->utils_query_nested_field(right_length, right_length, 0).trim()
   .indent_newlines(utils_indent(utils_get_max_name_length() + 5))
    /];[/if][/template]

[query public uml_c_have_operations(aSeq:Sequence(Classifier),
                                          vis : Set(VisibilityKind)):Boolean
 = not aSeq->select(c:Classifier| not c.uml_c_get_operations(vis)->isEmpty())
   ->isEmpty()/]

[template public uml_c_define_operations(aSeq:Sequence(Classifier),
                                          vis : Set(VisibilityKind),
                                          indentation : Integer)]
[for (aClassifier : Classifier | aSeq) separator(utils_newline()) 
      ?(not aClassifier.uml_c_get_operations(vis)->isEmpty())]
[for (o: Operation | aClassifier.uml_c_get_operations(vis)
                     ->sortedBy(o:Operation|o.name.toLower()))
     separator(utils_newline())]
[utils_indent(indentation)/][uml_c_operation_definition(o, indentation)/]
[/for]
[/for]
[/template]